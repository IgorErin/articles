\documentclass[14pt]{matmex-diploma-custom}

\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{array}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{color}

\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}
\definecolor{cyantypes}{rgb}{0.18,0.56,0.72}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\lstdefinelanguage{FSharp}%
{morekeywords={when, struct, let, new, match, with, rec, open, module, namespace, type, of, member, % 
and, for, while, true, false, in, do, begin, end, fun, function, return, yield, try, %
mutable, if, then, else, cloud, async, static, use, abstract, interface, inherit, finally },
  otherkeywords={ let!, return!, do!, yield!, use!, var, from, select, where, order, by },
  keywordstyle=\color{bluekeywords},
  sensitive=true,
  basicstyle=\ttfamily,
	breaklines=true,
  xleftmargin=\parindent,
  aboveskip=\bigskipamount,
	tabsize=4,
  morecomment=[l][\color{greencomments}]{///},
  morecomment=[l][\color{greencomments}]{//},
  morecomment=[s][\color{greencomments}]{{(*}{*)}},
  morestring=[b]",
  showstringspaces=false,
  literate={`}{\`}1,
  stringstyle=\color{redstrings},
  % new keyword colors
classoffset=1,
morekeywords={float32, AtLeastOne, Both, Left, Right, None, Some},
keywordstyle=\color{cyantypes},
classoffset=0,
}

\renewcommand{\lstlistingname}{Листинг}

\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

\graphicspath{{pictures/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\begin{document}

\filltitle{ru}{
    chair              = {Кафедра системного программирования},
    group              = {20Б.07-мм},
    title              = {Сложение разреженных матриц с использованием Brahma.FSharp},
    type               = {practice},
    kind               = {production},
    author             = {Гарбар Кирилл Анатольевич},
    supervisorPosition = {к.ф.-м.н., доцент кафедры информатики СПбГУ},
    supervisor         = {Григорьев С. В.},
}
\maketitle
\tableofcontents

\section*{Введение}
\paragraph{} Одной из самых известных структур данных информатики является граф. Графам находится применение в многих естественных науках, таких как биология~\cite{biology}, физика~\cite{physics} и химия~\cite{chemistry}. Помимо естественных наук, графы пользуются в различных областях математики --- теории групп~\cite{group}, топологии~\cite{topology}, теории вероятностей~\cite{probability}. Алгоритмы над графами получили широкое распространение в анализе социальных сетей.~\cite{social}.

Классическое представление графа в виде множеств вершин и дуг не всегда удобно для программирования алгоритмов на графах, поэтому граф часто представляется иным образом. Один из способов представить граф в памяти машины --- матрица смежности. Матрица смежности графа это квадратная матрица размера $N \times N$, где $N$ --- количество вершин графа. Ячейка $(i, j)$ матрицы отвечает за наличие дуги между вершинами $i$ и $j$. Такой способ представления графа используется на протяжении всей истории теории графов~\cite{Konig}. Алгоритмы обработки графов с матрицами смежности, написанные на языке линейной алгебры, были широко освещены в литературе~\cite{Kepner}.

Развитие идей о связи графов и разреженной линейной алгебры послужило толчком к созданию стандарта GraphBLAS\footnote{Описание GraphBLAS и ссылками на связанные материалы --- \url{https://graphblas.org/} (дата обращения: 20.05.2022)}\cite{Dongarra}, определяющего алгоритмы обработки графов на языке линейной алгебры с использованием разреженных матриц и векторов, заданных над полукольцами. Ярким примером таких алгоритмов является алгоритм вычисления достижимости пар вершин графа\footnote{Описание алгоритмов над графами через марицы смежности --- \url{https://users.math-cs.spbu.ru/~okhotin/teaching/algorithms_2020/okhotin_algorithms_2020_l5.pdf} (дата обращения: 20.05.2022)}. Для этого булева матрица смежности $ A \in \mathbb{B}^{n \times n}$ возводится в степень. Операциями сложения и умножения в булевом полукольце являются логическое ИЛИ и И соответственно. Таким образом, ячейка $(i, j)$ матрицы $A^l$ отвечает за наличие пути из вершины $i$ в вершину $j$ с длиной не более, чем $l$.

Граф, содержащий небольшое количество дуг относительно количества вершин, разумно представлять в виде разреженной, а не плотной матрицы. Одним из форматов разреженных матриц, активно используемых в GraphBLAS, является CSR\footnote{Описание различных форматов разреженных матриц --- \url{https://en.wikipedia.org/wiki/Sparse\_matrix} (дата обращения: 20.05.2022)} формат. Данный формат представляет матрицу в виде трёх массивов. Первый массив, называемый массивом значений, хранит все ненулевые\footnote{В разреженных матрицах, как правило, не хранят нейтральный по сложению элемент полукольца} элементы матрицы. Второй массив --- массив столбцов --- в ячейке с номером $i$ хранит номер столбца элемента с индексом $i$ в массиве значений. Наконец, третий 
массив, в ячейке с номером $i$ количество ненулевых элементов, содержащихся в строках с номером до $i-1$ включительно. Помимо CSR формата, используется также координатный формат. Первые два массива координатного представления матрицы идентичны массивам значений и столбцов из CSR формата, а третий --- массив строк --- аналогичен массиву столбцов.

С момента создания стандарта GraphBLAS появилось множество его реализаций. На данный момент, полной и образцовой реализацией выступает SuiteSparse:GraphBLAS\footnote{Описание SuiteSparse и ссылки на связанные материалы --- \url{https://people.engr.tamu.edu/davis/suitesparse.html} (дата обращения: 20.05.2022)}\cite{SS}. Помимо SuiteSparse существуют также GraphBLAST\footnote{Репозиторий проекта GraphBLAST --- \url{https://github.com/gunrock/graphblast} (дата обращения: 20.05.2022)}\cite{GBT}, CUSP\footnote{Репозиторий проекта CUSP --- \url{http://cusplibrary.github.io/index.html} (дата обращения: 20.05.2022)} и pggraphblas\footnote{Репозиторий проекта pggraphblas --- \url{https://github.com/michelp/pggraphblas} (дата обращения: 20.05.2022)}. Многие такие проекты работают с некоторыми ограничениями. Например, в SuiteSparse вычисления происходят на центральных процессорах, без поддержки параллельных вычислений на графических ускорителях, имеющих в данной области большой потенциал. Платформа OpenCL\footnote{Описание платформы OpenCL --- \url{https://www.khronos.org/opencl/} (дата обращения: 20.05.2022)}, в свою очередь, предоставляет поддержку как центральных, так и различных графических процессоров. Следует также заметить, что практически все реализации GraphBLAS написаны на языках C и C++, и реализация на более высокоуровневом языке программирования, таком как F\#, может иметь ряд преимуществ, таких как гибкая система типов, обилие статических проверок кода и функции высших порядков. В новых версиях C++ реализуются некоторые из приведённых приемуществ, но в F\# всё это было практически с момента его создания и поэтому реализовано более качественно. Проектом, стремящимся реализовать GraphBLAS на языке F\# с поддержкой платформы OpenCL является GraphBLAS-sharp\footnote{Репозиторий проекта GraphBLAS-sharp --- \url{https://github.com/YaccConstructor/GraphBLAS-sharp} (дата обращения: 20.05.2022)}.

Множество реализаций и растущая популярность не могли не породить множество дискуссий. Одной из активно обсуждаемых проблем, связанных c GraphBLAS, является проблема явных нулей\footnote{Обсуждение проблемы явных нулей с одним из основоположников стандарта GraphBLAS --- \url{https://github.com/GraphBLAS/LAGraph/issues/28} (дата обращения: 5.06.2022)}. Проблема связана с разреженными матрицами, а именно с тем, что такие матрицы, как правило, не хранят нулевой элемент полукольца, над которыми они заданы. Такие нули называются неявными. Однако, в результате операций полукольца, в матрице может оказаться нулевое значение, и, в зависимости от ситуации, может либо понадобиться сохранить его в матрице как явный ноль, либо удалить. Кроме того, иногда явный и неявный ноль могут иметь совершенно различную природу. Например, в задачах, связанных со взвешенными графами, неявный ноль может означать отсутствие ребра между двумя вершинами, а явный --- ребро с нулевым весом. Существует несколько подходов к решению данной проблемы. К примеру, в SuiteSparse для удаления явных нулей из матрицы используется отдельный метод. Недостатками такого способа может выступать потеря в производительности и банальное неудобство. Этого можно избежать, если операции, работающие с элементами матрицы, будут работать над типами, которые могут принимать как нулевое значение, которое будет являться явным, так и никакое значение вовсе, которое будет неявным нулём. В языке F\# такое можно естественным образом реализовать с помощью option типов.

\section{Постановка задачи}
\paragraph{} Целью данной работы является реализация операций разреженной линейной алгебры для GraphBLAS-sharp с использованием библиотеки Brahma.FSharp

  \textbf{Были сформулированы следующие задачи.}
  \begin{itemize}
    \item Реализовать поэлементное сложение разреженных матриц, представленных в CSR формате.
    \item Реализовать поддержку option типов в операции сложения элементов матриц, и предоставить возможность сложения матриц разных типов.
    \item С использованием различных графических процессоров произвести сравнение производительности полученного сложения матриц с SuiteSpase и CUSP, а также с Math.NET Numerics и с уже реализованным в GraphBLAS-sharp сложением в координатном формате.
  \end{itemize}

\section{Обзор}
\paragraph{}Обзор некоторых из существующих реализаций GraphBLAS, предыдущих результатов и библиотек, используемых в работе, представлен в данном разделе.

\subsection{Существующие реализации GraphBLAS}
\paragraph{} Аналоги, с которыми происходит сравнение, были отобраны по следующим критериям:
\begin{itemize}
    \item Присутствие ссылки на проект в репозитории\footnote{Репозиторий с ссылками на материалы про GraphBLAS --- \url{https://github.com/GraphBLAS/GraphBLAS-Pointers} (дата обращения: 20.05.2022)}, содержащем ссылки на связанные с GraphBLAS материалы.
    \item Наличие в поисковой выдаче Google по запросам ``GraphBLAS'' и ``Sparse linear algebra''.
\end{itemize}

Критерии по которым аналоги сравниваются между собой, следующие:
\begin{itemize}
    \item Поддержка платформы для параллельных вычислений.
    \item Язык программирования.
\end{itemize}

Результаты сравнения приведены в таблице~\ref{comparison}.
\begin{table}[h]
\center{}
    \begin{tabular}{ | c || c | c | c | c | }
      \hline
      Название & CPU & GPU Nvidia & GPU AMD & Язык \\
      \hline
      \hline
      SuiteSparse & Да & Нет & Нет & C \\ 
      \hline
      GraphBLAST & Нет & Да & Нет & C++ \\
      \hline
      CUSP & Нет & Да & Нет & C++ \\
      \hline
      pggraphblas & Да & Нет & Нет & C \\
      \hline
    \end{tabular}
\caption{Сравнение существующих решений}
\label{comparison}
\end{table}

Как видно в таблице~\ref{comparison}, не все реализации поддерживают вычисления на графических процессорах, а те, которые поддерживают, делают это с некоторыми ограничениями, такими как отсутствие поддержки центральных процессоров или поддержка графических процессоров только одной из фирм производителей. Также, все такие реализации написаны на языках C и C++, не обладающих гибким высокоуровневым интерфейсом.

\subsection{Математические библиотеки с поддержкой операций линейной алгебры}
\paragraph{} В связи с тем, что в GraphBLAS-sharp реализованы некоторые операции линейной алгебры, принято решение произвести сравнение производительности с одной из математических библиотек платформы .NET --- Math.NET Numerics\footnote{Описание Math.NET Numerics --- \url{https://numerics.mathdotnet.com/} (дата обращения: 20.05.2022)}. Math.NET Numerics выбран как одна из самых популярных математических библиотек платформы .NET, используемая в MATLAB\footnote{Описание MATLAB --- \url{https://www.mathworks.com/products/matlab.html} (дата обращения: 20.05.2022)} и множестве других проектов\footnote{Проекты, использующие Math.NET Numerics --- \url{https://numerics.mathdotnet.com/Users.html} (дата обращения: 20.05.2022)}.

\subsection{Используемая библиотека Brahma.FSharp}
\paragraph{} Поддержка платформы OpenCL, используемой в GraphBLAS-sharp, реализована на множестве платформ разных видов и производителей. Возможность писать код на высокоуровневом языке, исполняемый на платформе OpenCL, предоставляется библиотекой Brahma.FSharp\footnote{Репозиторий проекта Brahma.FSharp --- \url{https://github.com/YaccConstructor/Brahma.FSharp} (дата обращения: 20.05.2022)}, осуществляющей трансляцию кода из F\# в OpenCL. Разработчик может писать код на языке F\#, называемый ядром, которой затем будет транслирован в язык OpenCL С и исполнен на графическом или центральном процессоре асинхронно. Примитивом синхронизации в данном случае выступает очередь, реализуемая с помощью MailboxProcessor\footnote{Описание MailboxProcessor --- \url{https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpmailboxprocessor-1.html} (дата обращения: 20.05.2022)}.

\subsection{Предыдущие результаты}
\paragraph{} Для GraphBLAS-sharp уже была реализована операция поэлементного сложения разреженных матриц в координатном формате и префиксная сумма, результаты этой\footnote{Работа в которой было реализовано сложение координатных матриц --- \url{https://github.com/YaccConstructor/articles/blob/master/2021/diploma/Artem\%20Chernikov/report/Chernikov-report.pdf} (дата обращения: 20.05.2022)} работы будут использованы для рещения одной из поставленных задач --- поэлементного сложения матриц в CSR формате.

\section{Поэлементное сложение матриц}
\paragraph{} Описание решения первой из поставленных задач, а именно поэлементного сложения матриц в CSR формате, представлено в данном разделе.

В GraphBLAS-sharp CSR матрица реализована как запись $CSRMatrix$, содержащая количесвто строк и столбцов --- $RowCount$ и $ColumnCount$ соответственно, и трёх массивов --- $Values$, $Columns$ и $RowPointers$ --- аллоцируемых в памяти устройства, на котором будут производиться вычисления. 

\subsection{Реализация сложения}
\paragraph{} Для сложения был выбран стандартный алгоритм, который также используется в CUSP. Три этапа, составляющие данный алгоритм, следующие.
\begin{enumerate}
    \item Конвертация матрицы из CSR формата в координатный.
    \item Поэлементное сложение матриц в координатном формате.
    \item Конвертация результирующей матрицы обратно в CSR формат.
\end{enumerate}

\paragraph{} Массивы значений и столбцов для координатного и CSR форматов идентичны, а по массиву, содержащему количество ненулевых элементов в строках матрицы, естественным образом получается массив строк, аналогичный массиву столбцов. Таким образом, для конвертации матрицы в координатный формат, массивы $Values$ и $Columns$ копируются, а количество ненулевых элементов в $i$-ой строке матрицы определяется как $RowPointers[i + 1] - RowPointers[i]$. На каждый ненулевой элемент в строке $i$ в результирующий массив кладётся $i$, притом таким образом, что массив отсортирован по неубыванию. Затем матрицы, представленные в координатном формате, складываются по уже реализованному алгоритму.

Для обратной конвертации массивы $Values$ и $Columns$ копируются, а $Rows$ необходимо преобразовать в $RowPointers$. Для этого считается битовая карта уникальных элементов массива строк --- $bitmap$. На $i$-ой позиции в $bitmap$ стоит $0$ тогда и только тогда, когда $bitmap[i] = bitmap[i + 1]$. Затем, по массиву $bitmap$ считается исключающая префиксная сумма. Получается массив и значение суммы --- $positions$ и $totalSum$ соответственно. Массив $positions$ для каждого элемента $Rows$ хранит порядковый номер этого элемента как уникального. После этого создаются два массива длины $totalSum$ --- $nonZeroRowsIndices$ и $nonZeroRowsPointers$. Первый содержит номера непустых строк матрицы, а второй --- в ячейке $i$ хранит количество ненулевых элементов в строках до $i$ включительно. Для этого элемент с индексом $i$ массива $Rows$ кладётся в $nonZeroRowsIndices[positions[i]]$, а $i + 1$ --- в $nonZeroRowsPointers[positions[i]]$. Затем считается количество элементов в каждой непустой строке, полученные числа выставляются на соответствующие им места в результирующем массиве и с помощью включающей префиксной суммы конвертация завершается. 

\section{Option и сложение матриц разных типов}
\paragraph{} Ранее тип операции сложения был следующий: $typeA \rightarrow\ typeA \rightarrow\ typeA$, то есть по двум элементам одинакового типа получался третий элемент того же типа. Благодаря внедрению поддержки union типов в транслятор, частным случаем которых являются option типы, теперь можно задать операцию с сигнатурой $Option\ typeA \rightarrow Option\ typeA \rightarrow Option\ typeA$. Благодаря этому, пользователь, задающий бинарную операцию над элементами матриц, сможет сам решить, стоит ли сохранять получившиеся нули в явном виде, или нет. Следующим этапом повышения гибкости операции сложения стала возможность складывать матрицы разных типов. К примеру, написав соответствующую операцию сложения, теперь можно произвести сложение по маске или другие, более экзотические операции. Таким образом, сигнатура функции сложения стала выглядеть так: $Option\ typeA \rightarrow Option\ typeB \rightarrow Option\ typeC$. Однако, метод с такой сигнатурой не защищает пользователя от ошибки, ведь можно написать операцию, возвращающую по двум неявным нулям явное значение. В таком случае, ожидаемый результат будет далёк от реального, ведь разреженные матрицы не хранят неявные нули. Чтобы этого избежать, был введён новый тип --- $AtLeastOne$<$typeA, typeB$>, объявление типа приведено в листинге~\ref{lst:atleastone}. Данный тип гаранитурет, что среди пары элементов хотя бы один имеет явное значение. Итак, результатом преобразований стала сигнатура: $AtLeastOne$<$typeA, typeB$>$ \rightarrow Option\ typeC$.

\begin{lstlisting}[caption={Объявление типа AtLeastOne},label={lst:atleastone},language=FSharp, basicstyle=\small]
type AtLeastOne<'typeA, 'typeB when 'typeA: struct and 'typeB: struct> =
    | Both of 'typeA * 'typeB
    | Left of 'typeA
    | Right of 'typeB
\end{lstlisting}


\subsection{Реализация поддержки сложения матриц разных типов и option}
Для сложения матриц разных типов достаточно внести некотрые изменения в алгоритм сложения матриц в координатном формате. Первым этапом данного сложения является слияние трёх массивов, представляющих первую матрицу, с соответствующими массивами второй матрицы. Благодаря этому, если в обеих матрицах на одной и той же позиции хранится ненулевой элемент, в результате слияния эти элементы окажутся в соседних ячейках получившихся массивов. Так как теперь суммируемые матрицы могут хранить элементы различных типов, вместо одного массива значений в результате слияния получается два массива, хранящих элементы одного типа. В случае, когда на одной позиции элемент есть только в одной из матриц, необходимо знать, в каком из двух массивов после слияния он окажется. Для этого создаётся битовая карта, определяющий взят ли этот элемент из первой матрицы.

Следующим этапом является сложение пар элементов, получившихся в результате слияния. В случае, когда на одной позиции и в первой, и во второй матрице есть значение, всё остаётся по-прежнему. В случае, если элемент есть только в первой матрице, он складывается с неявным нулём правой матрицы, иначе элемент складывается с неявным нулём левой матрицы. В случае, когда результатом операции стал неявный ноль, никакое значение не кладётся в результирующий массив значений.

\section{Сравнительные эксперименты}
\paragraph{}В данном разделе описана постановка экспериментов по сравнению производительности и приведены полученные результаты, а также сделаны некоторые выводы.

\subsection{Постановка эксперимента}
\paragraph{}Для постановки экспериментов в GraphBLAS-sharp был создан отдельный проект под названием GraphBLAS-sharp.Benchmarks, в основе которого лежит инструмент BenchmarkDotNet\footnote{Обзор инструмента BenchmarkDotNet --- \url{https://benchmarkdotnet.org/articles/overview.html} (дата обращения: 20.05.2022)}. В проекте реализована загрузка матриц в формате Matrix Market\footnote{Описание Matrix Market  формата --- \url{https://math.nist.gov/MatrixMarket/formats.html} (дата обращения: 20.05.2022)} и их дальнейшие преобразования, выделение необходимой для эксперимента памяти и её чистка, а также замер времени исполнения нужного алгоритма над матрицами.

Матрицы, на которых ставился эксперимент, были взяты из The SuiteSparse Matrix Collection\footnote{Источник матриц для экспериментов --- \url{https://sparse.tamu.edu/} (дата обращения: 20.05.2022)}. Были отобраны матрицы разной степени разреженности и размера. Для каждой матрицы также заранее был посчитан её квадрат, с которым и складывалась исходная матрица. Выбранные матрицы приведены в таблице~\ref{matrices}.

\begin{table}[h]
\center{}

\begin{tabular}{ | c || c | c | c | }
\hline
Название & Размер & \parbox[c][2.5cm][t]{3cm}{\center{Количество ненулевых элементов}} & \parbox[c][3.5cm][t]{3cm}{\center{Количество ненулевых элементов у возведённой в квадрат}} \\ \hline
\hline
wing & 62 032 & 243 088 & 714,200 \\ \hline
luxembourg\_osm & 114 599 & 119 666 & 4 582 \\ \hline
amazon0312 & 400 727 & 3 200 440 & 14 390 544 \\ \hline
amazon-2008 & 735 323 & 5 158 388 & 25 366 745 \\ \hline
web-Google & 916 428 & 5 105 039 & 30 811 855 \\ \hline
webbase-1M & 1 000 005 & 3 105 536 & 51 111 996 \\ \hline
cit-Patents & 3 774 768 & 16 518 948 & 469 \\ \hline
\end{tabular}

\caption{Матрицы, на которых производилось сравнение}
\label{matrices}
\end{table}

Характеристики машины, на которой был поставлен эксперимент, следующие: Ubuntu 20.4, Intel Core i7-4790 CPU, 3.60GHz, DDR4 32GB RAM и GeForce GTX 2070, 8GB GDDR6, 1410 MHz.

Замеры производительности сложения матриц происходили следующим образом. Сперва матрица и её квадрат загружались из файлов как координатные матрицы, которые затем преобразовывались в формат CSR или СOO, в зависимости от эксперимента. После этого для каждой матрицы происходило десять разогревочных итераций эксперимента, за которыми следовало сто замеряемых итераций, в результате которых высчитывалось среднее значение и стандартное отклонение времени выполнения операции сложения.

\subsection{Результаты сравнения с SuiteSparse и CUSP}
\paragraph{}Наиболее интересным кандидатом для сравнения выступает SuiteSparse, ведь он является эталонной реализацией GraphBLAS. Также, для сравнения был выбран CUSP, так как алгоритмы сложения в GraphBLAS-sharp и CUSP аналогичны. Результаты замеров времени сложения приведены в таблице~\ref{platform-comparison}

\begin{table}
\centering
\begin{tabular}{|c||c|c|c|}
\hline
Название            & GraphBLAS-sharp & SuiteSparse & CUSP        \\
\hline
\hline
wing            & $1,8 \pm 0,1$      & $1,9\pm 0,1$   & $0,5\pm 0,2$   \\
\hline
luxembourg\_osm & $2,9 \pm 0,3$      & $1.9\pm 0,5$   & $0,5\pm 0,1$   \\
\hline
amazon0312      & $17,0 \pm 0,8$      & $28,9\pm 0,2$  & $2,8\pm 0,1$   \\
\hline
amazon-2008     & $12,2 \pm 0,8$     & $50,1\pm 2,4$  & $3,5\pm 0,1$   \\
\hline
web-Google      & $18,4 \pm 0,6$     & $58.8\pm 0,7$  & $3,6\pm 0,1$   \\
\hline
webbase-1M      & $70,7 \pm 1,0$      & $72,9\pm 0,4$  & $24,6\pm 2,1$  \\
\hline
cit-Patents     & $54,6 \pm 1,2$      & $157,4\pm 1,2$ & $8,5\pm 1,2$   \\     
\hline
\end{tabular}
\caption{Результаты сравнения библиотек на сложение в CSR формате, GTX 2070, среднее $\pm$ стандартное отклонение, мс}
\label{platform-comparison}
\end{table}

Из результатов видно, что полученное решение выигрывает в производительности вплоть до четырёх раз у SuiteSparse практически на всех матрицах. По сравнению с CUSP наблюдается проигрыш от трёх до семи раз.

\subsection{Результаты сравнения с Math.NET Numerics}
\paragraph{}Одной из наиболее используемых математических библиотек с поддержкой операций разреженной линейной алгебры на платформе .NET является Math.NET Numerics. Math.NET Numerics также поддерживает использование провайдеров алгоритмов для ускорения работы требующих производительности операций, поэтому для сложения матриц был использован Intel Math Kernel Library\footnote{Описание Intel MKL --- \url{https://en.wikipedia.org/wiki/Math_Kernel_Library} (дата обращения: 20.05.2022)}. Для хранения матриц в Math.NET Numerics используется CSR формат. Сравнение производительности CSR форматов в GraphBLAS-sharp и Math.NET Numerics приведены в таблице~\ref{mathnet-comparison}

\begin{table}
\centering
\begin{tabular}{|c||c|c|}
\hline
Название            & GraphBLAS-sharp & Math.NET Numerics     \\
\hline
\hline
wing            & $1,8 \pm 0,1$      & $5,5\pm 0,2$ \\
\hline
luxembourg\_osm & $2,9 \pm 0,3$       & $286,2\pm 2,2$ \\
\hline
amazon0312      & $17,0 \pm 0,8$     & $-$ \\
\hline
amazon-2008     & $12,2 \pm 0,8$    & $-$ \\
\hline
web-Google      & $18,4 \pm 0,6$      & $-$  \\
\hline
webbase-1M      & $70,7 \pm 1,0$      & $-$ \\
\hline
cit-Patents     & $54,6 \pm 1,2$      & $-$  \\       
\hline
\end{tabular}
\caption{Результаты сравнения библиотек на сложение в CSR формате, GTX 2070, среднее $\pm$ стандартное отклонение, мс. Отсутствие данных означает, что среднее время превышает 100 секунд}
\label{mathnet-comparison}
\end{table}

По результатам можно сделать вывод, что Math.NET Numerics не поддерживает операции с разреженными матрицами достаточно большого размера.

\subsection{Результаты сравнения CSR и COO сложения до и после внедрения option и сложения матриц разных типов}
\paagraph{}Вместе с внедрением поддержки option типов в транслятор, библиотека Brahma.FSharp претерпела множество изменений, в том числе и оптимизационных. В связи с этим, а также потому, что внедрение option типов в операцию сложения предполагает некоторое изменение алгоритма сложения, было произведено сравнение старой и новой версии сложения. Результаты приведены в таблице~\ref{option-comparison}

\begin{table}
\centering
\begin{tabular}{|с||с|с|с|с|} 
\hline
\multirow{2}{*}{Название} & \multicolumn{2}{с|}{Версия без option} & \multicolumn{2}{с|}{Версия с option}  \\ 
\cline{2-5}
                      & COO        & CSR                     & COO        & CSR           \\ 
\hline
\hline
wing                      & $19,7 \pm 0,2$ & $63,3 \pm 0,9$              & $0,8 \pm 0,1$  & $2,2 \pm 0,3$     \\ 
\hline
luxembourg\_osm           & $20,5 \pm 0,3$ & $62,3 \pm 1,3$              & $0,9 \pm 0,2$  & $2,8 \pm 0,3$     \\ 
\hline
amazon0312                & $27,8 \pm 0,4$ & $87,9 \pm 1,6$              & $5,4 \pm 0,6$  & $17,1 \pm 0,7$     \\ 
\hline
amazon-2008               & $26,1 \pm 0,3$ & $84,5 \pm 1,4$              & $4,1 \pm 0,5$  & $12,1 \pm 0,8$     \\ 
\hline
web-Google                & $27,6 \pm 0,4$ & $87,7 \pm 1,2$              & $5,2 \pm 0,2$  & $18,3 \pm 0,8$     \\ 
\hline
webbase-1M                & $51,9 \pm 0,7$ & $274,1 \pm 1,1$             & $44,6 \pm 1,0$ & $73,2 \pm 1,0$    \\ 
\hline
cit-Patents               & $30,4 \pm 0,5$ & $145,6 \pm 1,4$             & $13,9 \pm 0,7$  & $54,5 \pm 0,9$    \\
\hline
\end{tabular}
\caption{Результаты сравнения сложения для координатного и CSR форматов на GTX 2070, с использованием option типов и без, среднее $\pm$ стандартное отклонение, мс}
\label{option-comparison}
\end{table}

По результатам видно, что во всех случаях скорость сложения значительно возросла. Наибольшую роль в этом сыграла оптимизация библиотеки Brahma.FSharp.

\subsection{Результаты сравнения координатного и CSR форматов}
\paragraph{}Как в GraphBLAS-sharp, так и в CUSP сложение в CSR формате использует сложение в координатном формате, поэтому может быть полезно сравнить время сложения в координатном и CSR форматах. Результаты приведены в таблице~\ref{formats-comparison}

\begin{table}
\centering
\begin{tabular}{|c||c|c|c|c|} 
\hline
\multirow{2}{*}{Название} & \multicolumn{2}{c|}{GraphBLAS-sharp} & \multicolumn{2}{c|}{CUSP}  \\ 
\cline{2-5}
                          & COO        & CSR                     & COO        & CSR           \\ 
\hline
\hline
wing                      & $0,8 \pm 0,1$  & $1,8 \pm 0,1$          & $0,2 \pm 0,1$  & $0,5 \pm 0,2$     \\ 
\hline
luxembourg\_osm           & $0,9 \pm 0,2$  & $2,9 \pm 0,3$           & $1,7 \pm 0,2$  & $0,5 \pm 0,1$     \\ 
\hline
amazon0312                & $5,3 \pm 0,6$  & $17,0 \pm 0,8$             & $1,2 \pm 0,1$  & $2,8 \pm 0,1$    \\ 
\hline
amazon-2008               & $4,2 \pm 0,5$  & $12,2 \pm 0,8$              & $1,7 \pm 0,2$  & $3,5 \pm 0,1$    \\ 
\hline
web-Google                & $4,9 \pm 0,2$  & $18,4 \pm 0,6$             & $1,6 \pm 0,2$  & $3,6 \pm 0,1$     \\ 
\hline
webbase-1M                & $44.8 \pm 1,1$ & $70,7 \pm 1,0$             & $14,2 \pm 1,1$ & $24,6 \pm 2,1$  \\ 
\hline
cit-Patents               & $14,5 \pm 0,7$  & $54,6 \pm 1,2$            & $4,3 \pm 0,3$  & $8,5 \pm 1,2$   \\
\hline
\end{tabular}
\caption{Сравнение времени сложения матриц в CSR и COO форматах для GrahBLAS-sharp и CUSP, GTX 2070, среднее $\pm$ стандартное отклонение, мс}
\label{formats-comparison}
\end{table}

Как видно в таблице, в CUSP разница в координатном и CSR сложении составила около двух раз, в то время как в GraphBLAS-sharp --- от двух до четырёх раз.

\subsection{Результаты сравнения на разных устройствах}
\paragraph{}Чтобы выяснить, как ведёт себя полученное решение на разных устройствах, были проведены замеры времени сложения матриц в формате CSR на GTX 2070, 8GB GDDR6, 1410 MHz и GTX 1070, 8GB GDDR5, 1506 MHz, а также на Vega 10 XTX, 8GB HBM2, 1500 MHz. Полученные результаты приведены в таблице~\ref{device-comparison}

\begin{table}
\centering
\begin{tabular}{|с||с|с|с|} 
\hline
Название                 & GTX 1070             & GTX 2070             & Vega 10 XTX           \\ 
\hline
\hline
wing            & $2,3 \pm 0,2$      & $1,8 \pm 0,1$  &  $3,0 \pm 0,6$\\
\hline
luxembourg\_osm & $3,3 \pm 0,3$       & $2,9 \pm 0,3$  & $3,4 \pm 0,4$\\
\hline
amazon0312      & $19,7 \pm 0,7$     & $17,0 \pm 0,8$  & $22,3 \pm 1,3$\\
\hline
amazon-2008     & $14,5 \pm 0,9$    & $12,2 \pm 0,8$  & $20,0 \pm 0,8$\\
\hline
web-Google      & $21,2 \pm 0,6$      & $18,4 \pm 0,6$& $26,0 \pm 1,3$\\
\hline
webbase-1M      & $78,4 \pm 1,1$      & $70,7 \pm 1,0$ & $240,8 \pm 2,4$\\
\hline
cit-Patents     & $59,8 \pm 1,1$      & $54,6 \pm 1,2$  & $94,7 \pm 0,1$\\ 
\hline
\end{tabular}
\caption{Результаты сравнения сложения CSR матриц на разных устройствах, среднее $\pm$ стандартное отклонение, мс}
\label{device-comparison}
\end{table}

Из полученных результатов видно, что наибольшую производительность показала GTX 2070, в то время как GTX 1070 оказалась несколько медленнее. Наименьшую производительность показала Vega 10 XTX с особо существенным отставанием на больших матрицах.  

\subsection{Результаты сравнения поэлементного умножения в GraphBLAS-sharp и CUSP}
\paragraph{} Задав поэлементную операцию определённым образом, можно получить не только сложение матриц. Примером другой такой операции является поэлементное умножение, которое, в отличие от сложения, работает на пересечении множеств элементов двух матриц. В SuiteSparse для каждой из этих операций используется свой алгоритм, когда в GraphBLAS-sharp достаточно написать только новую бинарную операцию, как представлено на листинге~\ref{lst:ewisemul}. Результаты сравнения поэлементного умножения в GraphBLAS-sharp и SuiteSparse приведены в таблице~\ref{mult-comparison}

\begin{lstlisting}[caption={Операция поэлементного умножения в GraphBLAS-sharp},label={lst:ewisemul},language=FSharp, basicstyle=\small]
let float32Mul =
    <@ fun (values: AtLeastOne<float32, float32>) ->
        let mutable res = 0f

        match values with
        | Both (f, s) -> res <- f * s
        | _ -> res <- 0f

        if res = 0f then None else (Some res) @>
\end{lstlisting}

\begin{table}
\centering
\begin{tabular}{|c||c|c|}
\hline
Название            & GraphBLAS-sharp & SuiteSparse    \\
\hline
\hline
wing            & $2,5 \pm 0,4$      & $1,0 \pm 0,1$ \\
\hline
luxembourg\_osm & $2,6 \pm 0,3$       & $1,4 \pm 0,3$ \\
\hline
amazon0312      & $13,0 \pm 1,0$     & $23,0 \pm 0,9$ \\
\hline
amazon-2008     & $9,1 \pm 0,8$    & $35,2 \pm 4,0$ \\
\hline
web-Google      & $14,7 \pm 0,8$      & $43,9 \pm 0,2$  \\
\hline
webbase-1M      & $55,4 \pm 1,2$      & $31,0 \pm 1,6$ \\
\hline
cit-Patents     & $47,9 \pm 0,9$      & $107,9 \pm 0,4$  \\     
\hline
\end{tabular}
\caption{Сравнение результатов поэлементного умножения матриц, GTX 2070, среднее $\pm$ стандартное отклонение, мс}
\label{mult-comparison}
\end{table}

По результатам эксперимента видно, что на большей части матриц наблюдается выигрыш в производительности, в то время как отставание на остальных матрицах не столь значительное.

\subsection{Вывод}
\paragraph{}Выводы, сформулированные в результате анализа данных, полученных в ходе эксперимента, следующие.
\begin{itemize}
    \item Благодаря оптимизации транслятора была достигнута высокая производительности полученного решения.
    \item По сравнению с эталонной реализацией стандарта, использующей центральный процессор для вычислений, наблюдается выигрыш в производительности. Тем не менее, отставание от CUSP составило от трёх до семи раз.
    \item Сложение в CSR формате существенно отстаёт в производительности от сложения в координатном формате.
    \item Наилучшей производительности удалось добиться на устройствах компании Nvidia.
    \item Несмотря на то, что GraphBLAS-sharp написан на высокоуровневом языке платформы .NET, была достигнута приемлемая производительность даже по сравнению с реализациями на C/C++. Отсюда можно сделать вывод о конкурентоспособности полученного решения.
\end{itemize}

\section*{Заключение}
\paragraph{}В ходе данной работы были выполнены следующие задачи.
\begin{itemize}
    \item Реализовано поэлементное сложение разреженных матриц, представленных в CSR формате.
    \item Реализована поддержка option типов в операции сложения элементов матриц, а также добавлена возможность сложения матриц разного типа.
    \item С использованием различных графических процессоров произведено сравнение производительности полученного сложения матриц с SuiteSpase и CUSP, а также с Math.NET Numerics и с уже реализованным в GraphBLAS-sharp сложением в координатном формате.
\end{itemize}

Помимо этого, была создана инфраструктура для дальнейшего проведения экспериментов по сравнению с аналогами. В дальнейшие планы входит как реализация большего количества строительных блоков для алгоритмов над графами, так и реализация самих алгоритмов.

Код доступен в репозитории на сервисе github\footnote{Репозиторий проекта GraphBLAS-sharp --- \url{https://github.com/kirillgarbar/GraphBLAS-sharp} (дата обращения: 20.05.2022)}.
Имя пользователя: kirillgarbar

\bibliographystyle{ugost2008ls}
\bibliography{report.bib}

\end{document}