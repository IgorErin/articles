\section*{Introduction}\label{sec:introduction}

Graph-structured data models are widely used in many scientific application domains~\cite{robinson2015graph} such as social network analytics ~\cite{10.1145/2463664.2465216},  biological knowledge graph management \cite{rna}, and static code analysis~\cite{10.1145/2499370.2462159}. One of the main advantages of this model over the relational data model is that obtaining information about the relationship between objects is very fast. The relationships between nodes are not calculated during query execution but stored in the model itself. One of the most common tasks associated with analyzing data represented by graphs is searching for paths. In graph databases queries are used for paths analysis. The natural way of specifying it is to impose restrictions on paths between vertices.

One can express such queries by defining formal grammar over an alphabet of edge labels. A path belongs to the language specified by the formal grammar if the language contains the word obtained by concatenating the edge labels of the given path~\cite{arcbool}. Most often, with this approach, regular grammar is taken. For example, one of the most common graph databases Neo4j uses a declarative language called Cypher as a query language. It supports path constraints in terms of regular languages. It is noteworthy that Cypher supports regular constraints only partially, and at this moment its query language is quite limited and it does not provide sufficient expressive power in a variety of domains. One way to extend the expressiveness of queries is by using constraints in terms of context-free languages. Context-free path queries strictly extend the expressive power of regular path queries for sophisticated graph analytics and thus this is suitable a wider class of problems. One of these problems is the same-generation query. In bioinformatics, the aim of such queries is to determine paths between species in a genealogical database where the species are at the same level in the species-subspecies hierarchy. The query is expressible in terms of context-free languages, but there is no way to express it in terms of regular expressions~\cite{10.1007/978-3-319-91662-0_17}. 

Despite the fact that the problem of context-free paths querying is well studied and a lot of algorithms were proposed~\cite{10.1145/3210259.3210264, zhang2016contextfree, hellings2016querying, medeiros2020algorithm}, there are still a number of problems associated with its applicability in the analysis of real data. The most critical problems are the poor performance of existing algorithms on real-world data and bad integration with  real-world graph databases and graph analysis systems~\cite{10.1145/3335783.3335791}. These problems hinder the adoption of CFPQ.

The problem with the performance of CFPQ algorithms in real-world scenarios was pointed out by Jochem Kuijpers~\cite{10.1145/3335783.3335791} as a result of an attempt to extend the Neo4j graph database with CFPQ. The number of the state of the art methods for CFPQ processing were selected~\cite{10.1007/978-3-319-91662-0_17, hellingsRelational, 10.1145/3167132.3167265, 10.1145/3398682.3399163}. The authors implemented them using Neo4j as a graph storage and evaluated them. The results of comparison of measured performance showed that these solutions are not able to cope with large graphs as found in practice.

One of the implemented methods uses matrix representation to get the information about reachability in a given graph. This method was proposed by Rustam Azimov in~\cite{10.1145/3398682.3399163} and is based on matrix operations.
Since the performance problem was pointed out, it was shown that this algorithm demonstrates good performance enough. Moreover, the matrix-based CFPQ algorithm has become the base for the first full-stack support of CFPQ by extending the RedisGraph graph database. 

Matrix representation is not the only one way to express CFPQ algorithms. Moreover, research shows that basic parsing algorithms that accept string and grammar can be straightforwardly generalized for graph input~\cite{10.1145/3166094.3166104}. For example, there are efforts that describe how the CFPQ problem can be solved by using a generalized LL analyzer or a generalized LR analyzer.
It is worth noting that such an approach allows getting information not only about reachability in the graph but also solves all paths problem~\cite{10.1007/978-3-030-61133-0_7}. However, such practical cases of getting information about reachability and paths are not studied enough. 

The combination of these factors motivates further research and implementation of new solutions. On the other hand, there exists the recent development of the CFPQ problem~\cite{10.1007/978-3-662-46663-6_5} integrated with the Neo4j graph database\footnote{ Github repository of modificated GLL algorithm: \url{https://github.com/YaccConstructor/iguana},  last accessed: 05/05/2022}. This is the adaptation of the classic Generlized LL parsing algorithm for execution of context-free queries on graphs. It is important to note that the resulting algorithm supports the entire class of context-free languages. The modified GLL algorithm, just like the original one, returns information not only about reachability between vertices, but also information for reconstructing the paths themselves. A special data structure is used for this purpose called Shared Packed Parse Forest (SPPF).
However, this data structure consumes a significant amount of resources and, as a result, leads to worse performance of the entire algorithm. In practice, the limitations on processor resources are quite significant, and the paths themselves are not always required: it would be enough to obtain only information about their existence. What is more, there is no investigation on providing parallel solutions based not on linear-algebra-oriented algorithms. In the multi- and many-core world and the big data era, it is important to provide a parallel solution for CFPQ. 

Thus, the aim of this work is to provide an implementation of the GLL algorithm to graph handling for both the \texttt{all paths} and the \texttt{reachability} scenarios. Then, it is planned in this work to make an evaluation of the proposed solution to investigate whether significant performance improvements could be achieved.
