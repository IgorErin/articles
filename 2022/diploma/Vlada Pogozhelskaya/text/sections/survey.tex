\section{Related work \& background}
This section includes basic notation and definitions in graph theory and formal language theory which are used in this work. Also, the further description of both the theoretical part of the GLL-based CFPQ algorithm and its implementation are provided.

\subsection{Basic Definitions of Formal Languages}

In this work, the context-free grammars are used as path constraints, thus context-free languages and grammars are defined in this subsection.

\begin{rudefinition}A \emph{context-free grammar} is a tuple $G= \langle N, \Sigma, P, S \rangle$, where
\begin{itemize}
    \item $N$ is a finite set of nonterminals
    \item $\Sigma$ is a finite set of terminals, $N \cap \Sigma = \varnothing$
    \item $P$ is a finite set of productions of the form $A \to \alpha$, where $A \in N,\ \alpha \in (N \cup \Sigma)^*$
    \item $S$ $\in$ $N$.
\end{itemize} \qed
\end{rudefinition}

We use the conventional notation $A \Rightarrow^* w$ to denote, that a
word $w \in \Sigma^*$ can be derived from a non-terminal $A$ using some sequence of production rules from $P$.

\begin{rudefinition} A \emph{context-free language} is a language generated by a con-text-free grammar $G$:
\begin{align*}
     L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w \}
\end{align*}
\end{rudefinition}

% \begin{rudefinition} A \emph{context-free language with a specified starting non-terminal $S$} is a set of strings that can be generated from $S$ by a context-free grammar $G$:
% \begin{align*}
%      L(G_S) = \{w \in \Sigma^* \mid S \Rightarrow^* w \}
% \end{align*}
% \end{rudefinition}

\subsection{Basic Definitions of Graph Theory}
In a simplified way, the Neo4j graph database uses a labeled directed graph as a data model. It can be defined as follows.

\begin{rudefinition} \emph{Labeled directed graph} is a tuple $D = \langle V, E, T \rangle$, where
\begin{itemize}
    \item $V$ is a finite set of vertices. For simplicity, we assume that the vertices are natural numbers from $0$ to $|V|-1$.
    \item $T$ is a set of labels on edges.
    \item $E \subseteq V \times T \times V$ is a set of edges.
\end{itemize} \qed
\end{rudefinition}

\begin{rudefinition}
Path $\pi$ in the graph $D = \langle V, E, T \rangle$ is a finite sequence of edges $(e_0, e_1, ..., e_{n-1})$, where $\forall~ j,~ 0 \leq j \leq n - 1: e_j=(v_j,t_j,v_{j+1}) \in E$.

We denote the set of all paths in the graph $D$ as $\pi(D)$. \qed
\end{rudefinition}

\subsection{Context-free Path Querying}
Now, we can define context-free path querying problems. Let be:
\begin{itemize}
      \item a context-free grammar $G=\langle N, \Sigma, P, S \rangle$;
      \item a directed graph $D=\langle V, E, T \rangle$, where $V$ is the set of vertices of the graph, $ E \subseteq V \times T \times V $ is the set of edges, $ T \subseteq \Sigma $ is the set of labels on edges, where each label is a terminal symbol of the grammar $G$;
\item a set of start vertices $V_S \subseteq V$ and final vertices \mbox {$V_F \subseteq V$.}
\end{itemize}

Consider a path in the graph $D$: $$\pi = (e_0, e_1, \cdots, e_{n - 1}), $$ where $ e_k = (v_{k}, t_k , v_{k+1}), ~ \forall~k,~ 0 \leq k \leq n - 1 ~e_k \in E$.
To path in the graph the word $ l(\pi) = t_0t_1 \cdots t_{n_1} $ is associated --- the concatenation of the labels on the edges of this path.

In the introduced notation, the following problems can be formulated.

\begin{itemize}
     \item \textbf{The problem of a path querying in a graph with context-free constraints} consists in finding all paths in the graph such that $l(\pi) \in L (G)$ and $v_0 \in V_S, ~v_n \in V_F$.
    
     \item \textbf{The problem of reachability in a graph with context-free constraints} consists in finding a set of pairs of vertices for which there is a path with a beginning and an end at these vertices, such that the word composed of labels of the edges of the path  belongs to the given language: $ \{(v_i, v_j) ~ | ~ \exists ~ l (\pi) \in L (G) $ and $ v_0 \in V_S, ~ v_n \in V_F \} $.
\end{itemize}

It should be noted that it is often necessary to identify complex dependencies in a graph data model. So, according to the context and application area, both variants of the above problems are of practical importance. 

For each problem there are two variants of set of starting vertices: the set may consist of all vertices of a graph or may consist only a particular vertices of interest. The first variant is called all-pairs context-free path querying problem and the second is called a multiple-source (and a single-source as a partial case) context-free path querying problem.

\subsection{Generalized LL Parsing Algorithm}
One of the common parsing techniques is the LL(k) algorithm~\cite{10.5555/1076440}, that performs top-down analysis with a lookahead. It means that the decision about which production of the grammar should be applied is based on looking at the $ k $ following character from the current one. To choose the right production rule at this step algorithm supports a parsing table, where the information for parsing the current non-terminal is stored. However, it can be applied only to a subset of the context-free grammars class and does not support ambiguous context-free grammars or grammars with left recursion in derivation.

Top-down analysis algorithms are relatively easier to implement and debug, because it fully matches the structure of the grammar. For this reason, to extend the parsing power of above-mentioned technique there was proposed~\cite{SCOTT2010177} the generalized LL (GLL) algorithm. Also GLL can handle ambiguous grammars.
In case of LL(k) algorithm may arise the situation when it is impossible to determine which production should be applied in the current state of the parsing process ~\cite{10.1145/800105.803402}. To solve this issue the GLL algorithm maintains a queue of descriptors. Each descriptor is a structure that describes the current state of the analyzer. Thus, using a queue of descriptors allows one to consider all possible transitions during the operation of the parser.

The parsing table for the generalized GLL algorithm can store multiple alternatives for parsing the current non-terminal. In this case, descriptor duplication can occur. For efficient storage and reuse of many different descriptors, GLL uses a specific structure --- Graph Structured Stack (GSS)~\cite{10.5555/1623611.1623625}.

To represent the result, GLL provides the Shared Packed Parse Forest (SPPF) structure~\cite{SCOTT20131828}, which contains all derivation trees for all paths satisfying the specified language.

\subsection{GLL-based CFPQ Algorithm}
As it was showed, classical GLL parsing technique can be used to solve context-free language constrained path problem. It means that such technique can be used to proceed graph input. Previously, the algorithm was generalized from linear input to graph processing, as was described in \cite{10.1145/3166094.3166104}.

To do this, the following modifications were proposed.
\begin{itemize}
\item A query has became a triple: a set of initial vertices, a set of final vertices, and a grammar.
\item An initial set of descriptors must include all the start vertices of the graph.
\item At the step of transition to the next character, it is necessary to support all possible transition options that correspond to all outgoing edges of the vertex.
\item If parsing is completed, it is necessary to check whether the final vertex in the parsing belongs to the set of final vertices of the graph.
\end{itemize}

The described principles of the generalized GLL algorithm are important for understanding the features of its implementation, which will be described below.

The implementation of the algorithm is based on the Iguana project which is written in Java. This library provides the modified GLL algorithm. The advantage of  Iguana project is that it uses a more efficient GSS for GLL parsing. In addition, it does not affect the worst-case cubic run time and space complexities of GLL parsing.
 
Under this work, it is important to pay attention to the following changes that were made to the workflow of the GLL algorithm to unable graph processing.

\begin{itemize}
    \item In order to support graph processing, the abstraction of an input data was changed. The new implementation of the $Input$ interface has been added. Now it is represented as a graph adjacency list, a set of start and final vertices of the resulting paths.
    \item There can be multiple start vertices for a graph input, unlike a linear input. So, also the initialization of the descriptor queue was modified. In case of processing a descriptor with slot $(N \rightarrow \alpha.x\beta)$, where $x$ is a terminal, the nextSymbols method was used. It took an index $i$ in the input string and returns an index $j$ such that the substring of the input string from $i$ to $j - 1$ matches $x$. Thus, $ j $ is the index in the input string from which the parsing  should continue by going to the slot $(N \rightarrow \alpha x.\beta)$. Considering the graph input there can be several similar positions. Therefore, the signature of this method has been changed. Now it returns a list of identifiers.
\end{itemize}

As far as the original GLL is aimed to handle arbitrary context-free grammars, this solution can handle arbitrary grammars too. It makes the solution less restrictive with regard to a query specification language, thus being more user-friendly.

%As a storage for graphs,the Neo4j graph database was used. This is the most commonly used graph DBMS. Neo4j supports Cypher query language and represents data as nodes (vertices) and relations between them (edges). Vertices and edges can be labeled. Neo4j is an open source project and, like Iguana, implemented in Java. The modified algorithm has been integrated with Neo4j using the Native Java API.

