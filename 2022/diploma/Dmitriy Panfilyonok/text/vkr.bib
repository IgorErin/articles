@INPROCEEDINGS{gb_math,
  author={J. {Kepner} and P. {Aaltonen} and D. {Bader} and A. {Buluç} and F. {Franchetti} and J. {Gilbert} and D. {Hutchison} and M. {Kumar} and A. {Lumsdaine} and H. {Meyerhenke} and S. {McMillan} and C. {Yang} and J. D. {Owens} and M. {Zalewski} and T. {Mattson} and J. {Moreira}},
  booktitle={2016 IEEE High Performance Extreme Computing Conference (HPEC)}, 
  title={Mathematical foundations of the GraphBLAS}, 
  year={2016},
  volume={},
  number={},
  pages={1-9},
  doi={10.1109/HPEC.2016.7761646}
}

@article{sevengr,
title = {Graphs, Matrices, and the GraphBLAS: Seven Good Reasons},
journal = {Procedia Computer Science},
volume = {51},
pages = {2453-2462},
year = {2015},
note = {International Conference On Computational Science, ICCS 2015},
issn = {1877-0509},
doi = {https://doi.org/10.1016/j.procs.2015.05.353},
url = {https://www.sciencedirect.com/science/article/pii/S1877050915011618},
author = {Jeremy Kepner and David Bader and Aydın Buluç and John Gilbert and Timothy Mattson and Henning Meyerhenke},
keywords = {graphs, algorithms, matrices, linear algebra, software standards},
abstract = {The analysis of graphs has become increasingly important to a wide range of applications. Graph analysis presents a number of unique challenges in the areas of (1) software complexity, (2) data complexity, (3) security, (4) mathematical complexity, (5) theoretical analysis, (6) serial performance, and (7) parallel performance. Implementing graph algorithms using matrix-based approaches provides a number of promising solutions to these challenges. The GraphBLAS standard (istc-bigdata.org/GraphBlas) is being developed to bring the potential of matrix based graph algorithms to the broadest possible audience. The GraphBLAS mathematically defines a core set of matrix-based graph operations that can be used to implement a wide class of graph algorithms in a wide range of programming environments. This paper provides an introduction to the GraphBLAS and describes how the GraphBLAS can be used to address many of the challenges associated with analysis of graphs.}
}

@inproceedings{cusha,
author = {Khorasani, Farzad and Vora, Keval and Gupta, Rajiv and Bhuyan, Laxmi N.},
title = {CuSha: Vertex-Centric Graph Processing on GPUs},
year = {2014},
isbn = {9781450327497},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2600212.2600227},
doi = {10.1145/2600212.2600227},
abstract = {Vertex-centric graph processing is employed by many popular algorithms (e.g., PageRank) due to its simplicity and efficient use of asynchronous parallelism. The high compute power provided by SIMT architecture presents an opportunity for accelerating these algorithms using GPUs. Prior works of graph processing on a GPU employ Compressed Sparse Row (CSR) form for its space-efficiency; however, CSR suffers from irregular memory accesses and GPU underutilization that limit its performance. In this paper, we present CuSha, a CUDA-based graph processing framework that overcomes the above obstacle via use of two novel graph representations: G-Shards and Concatenated Windows (CW). G-Shards uses a concept recently introduced for non-GPU systems that organizes a graph into autonomous sets of ordered edges called shards. CuSha's mapping of GPU hardware resources on to shards allows fully coalesced memory accesses. CW is a novel representation that enhances the use of shards to achieve higher GPU utilization for processing sparse graphs. Finally, CuSha fully utilizes the GPU power by processing multiple shards in parallel on GPU's streaming multiprocessors. For ease of programming, CuSha allows the user to define the vertex-centric computation and plug it into its framework for parallel processing of large graphs. Our experiments show that CuSha provides significant speedups over the state-of-the-art CSR-based virtual warp-centric method for processing graphs on GPUs.},
booktitle = {Proceedings of the 23rd International Symposium on High-Performance Parallel and Distributed Computing},
pages = {239–252},
numpages = {14},
keywords = {graph representation, gpu, g-shards, coalesced memory accesses, concatenated windows},
location = {Vancouver, BC, Canada},
series = {HPDC '14}
}

@inproceedings{mGPU,
author = {Pan, Yuechao and Wang, Yangzihao and Wu, Yuduo and Yang, Carl and Owens, John},
year = {2017},
month = {05},
pages = {479-490},
title = {Multi-GPU Graph Analytics},
doi = {10.1109/IPDPS.2017.117}
}

@article{blast,
  author    = {Carl Yang and
               Aydin Bulu{\c{c}} and
               John D. Owens},
  title     = {GraphBLAST: {A} High-Performance Linear Algebra-based Graph Framework
               on the {GPU}},
  journal   = {CoRR},
  volume    = {abs/1908.01407},
  year      = {2019},
  url       = {http://arxiv.org/abs/1908.01407},
  archivePrefix = {arXiv},
  eprint    = {1908.01407},
  timestamp = {Fri, 09 Aug 2019 12:15:56 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1908-01407.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{opencl_pl,
author = {Ukidave, Yash and Ziabari, Amir Kavyan and Mistry, Perhaad and Schirner, Gunar and Kaeli, David},
year = {2013},
month = {04},
pages = {},
title = {Quantifying the Energy Efficiency of FFT on Heterogeneous Platforms},
journal = {ISPASS 2013 - IEEE International Symposium on Performance Analysis of Systems and Software},
doi = {10.1109/ISPASS.2013.6557174}
}

@article{fusion,
  author    = {Jiri Filipovic and
               Matus Madzin and
               Jan Fousek and
               Ludek Matyska},
  title     = {Optimizing {CUDA} Code By Kernel Fusion---Application on {BLAS}},
  journal   = {CoRR},
  volume    = {abs/1305.1183},
  year      = {2013},
  url       = {http://arxiv.org/abs/1305.1183},
  archivePrefix = {arXiv},
  eprint    = {1305.1183},
  timestamp = {Mon, 13 Aug 2018 16:46:55 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1305-1183.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{deforset,
title = {Deforestation: transforming programs to eliminate trees},
journal = {Theoretical Computer Science},
volume = {73},
number = {2},
pages = {231-248},
year = {1990},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(90)90147-A},
url = {https://www.sciencedirect.com/science/article/pii/030439759090147A},
author = {Philip Wadler},
abstract = {An algorithm that transforms programs to eliminate intermediate trees is presented. The algorithm applies to any term containing only functions with definitions in a given syntactic form, and is suitable for incorporation in an optimizing compiler.}
}

@manual{ocl,
  added-at = {2016-09-22T13:24:24.000+0200},
  author = {{Khronos OpenCL Working Group}},
  biburl = {https://www.bibsonomy.org/bibtex/26b05670e3e58d5d057a39491d129cad4/cepek},
  editor = {Munshi, Aaftab},
  interhash = {c9067650b463bd1cf1a9958491a0aadc},
  intrahash = {6b05670e3e58d5d057a39491d129cad4},
  keywords = {geoinformatics_fce_ctu_ref imported},
  timestamp = {2016-09-22T13:29:55.000+0200},
  title = {The OpenCL Specification, Version 1.1},
  url = {https://www.khronos.org/registry/cl/specs/opencl-1.1.pdf},
  year = 2011
}


@article{ocl_sp,
author = {Hong, Jung-Hyun and Ahn, Young-Ho and Kim, Byung-Jin and Chung, Ki},
year = {2014},
month = {05},
pages = {233-241},
title = {Design of OpenCL Framework for Embedded Multi-core Processors},
volume = {60},
journal = {Consumer Electronics, IEEE Transactions on},
doi = {10.1109/TCE.2014.6851999}
}