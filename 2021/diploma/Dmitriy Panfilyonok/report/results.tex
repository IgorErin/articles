\subsection{Эксперименты}
\paragraph{}
Для апробации предлагаемого решения был реализован алгоритм поиска в ширину из единственной вершины. Предлагаемая реализация сравнивалась с другой библиотекой для анализа графов на платформе .NET --- QuickGraph\footnote{Репозиторий библиотеки QuickGraph: \url{https://github.com/YaccConstructor/QuickGraph}. Дата посещения: 01.06.2021}. Набор данных состоит из 4 квадратных матриц, взятых из коллекции матриц SuiteSparse Matrix Collection\cite{matcol}. Характеристики каждой матрицы представлены в таблице~\ref{tab:dataset}. Сравнение поводилось с помощью библиотеки BenchmarkDotNet\footnote{Репозиторий библиотеки BenchmarkDotNet \url{https://github.com/dotnet/BenchmarkDotNet}. Дата посещения: 01.06.2021} на ПК с операционной системой Windows 10 в конфигурации Intel Core i5-4690K CPU 3.50GHz, DDR3 8GB RAM, GeForce GTX 970, 4GB VRAM. Для каждой матрицы алгоритм запускался от 20 до 100 раз из случайной вершины. Перед запуском матрица была загружена в видеопамять, поэтому затраты на копирование матрицы не учитывались. Подобный принцип проведения экспериментов используется в эталонном решении для измерения производительности алгоритмов на графах GAP Benchmark Suite\cite{gap}.
В таблицах~\ref{tab:bfs-gb} и~\ref{tab:bfs-qg} представлены результаты сравнения.

\begin{table}[h]
    \begin{tabularx}{\textwidth}{|X|X|X|}
      \hline
      Название матрицы & Число строк/столбцов, $|V|$ & Число ненулевых элементов, $|E|$\\
      \hline
      arc130 & 130 & 1282 \\
      linux-call-graph & 324085 & 1208908\\
      webbase-1M & 1000005 & 3105536 \\
      cit-Patents & 3774768 & 16518948 \\ 
      \hline
    \end{tabularx}
  \caption{Параметры используемых графов}
  \label{tab:dataset}
\end{table}

\begin{table}[h]
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
      \hline
      Матрицы & Среднее, мс & Ошибка, мс & Медиана, мс \\
      \hline
      arc130 & 346 & 9.9 & 347.9 \\
      linux-call-graph & 17453.4 & 5841.5 & 8765.3 \\
      webbase-1M & 17367.1 & 5978.9 & 9867.5 \\
      cit-Patents & 6345.4 & 2187.9 & 2888.4 \\ 
      \hline
    \end{tabularx}
  \caption{Оценка времени работы алгоритма в библиотеке GraphBLAS-sharp}
  \label{tab:bfs-gb}
\end{table}

\begin{table}[h]
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
      \hline
      Матрица & Среднее, мс & Ошибка, мс & Медиана, мс \\
      \hline
      arc130 & 0.063 & 0.01 & 0.063 \\
      linux-call-graph & 8.5 & 0.7 & 9.6 \\
      webbase-1M & 23.6 & 2.5 & 18.7 \\
      cit-Patents & 137.6 & 2.6 & 136.6 \\ 
      \hline
    \end{tabularx}
  \caption{Оценка времени работы алгоритма в библиотеке QuickGraph}
  \label{tab:bfs-qg}
\end{table}

% Кроме того, была отдельна измерена операция умножения матрицы в CSR формате на разреженный вектор. Результаты представлены в таблице.

Из результатов видно, что предлагаемое решение на несколько порядков проигрывает QuickGraph на небольших данных, но с ростом числа ненулевых элементов разница сокращается, хотя и остается очень большой. 

\subsection{Выводы}
\paragraph{}

Низкая производительная предлагаемого решения может иметь нес\-коль\-ко причин.
\begin{itemize}
    \item Во-первых, наличие больших накладных расходов на копирование данных между управляемой, неуправляемой и видеопамятью.
    \item Во-вторых, компиляция кода ядер во время исполнения может занимать много времени. Возможно, имеет смысл кэшировать уже скомпилированные ядра.
    \item В-третьих, отсутствие атомарных операций для произвольных типов данных не позволяет реализовывать некоторые алгоритмы, которые могут оказаться лучше аналогов.
\end{itemize}

Кроме того, использование OpenCL из высокоуровневого языка с управляемой памятью затрудняет профилирование кода, что усложняет поиск факторов, ограничивающих производительность библиотеки.