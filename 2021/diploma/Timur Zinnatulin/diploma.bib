@inproceedings{10.1145/298514.298576,
author = {Yannakakis, Mihalis},
title = {Graph-Theoretic Methods in Database Theory},
year = {1990},
isbn = {0897913523},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/298514.298576},
doi = {10.1145/298514.298576},
booktitle = {Proceedings of the Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {230–242},
numpages = {13},
location = {Nashville, Tennessee, USA},
series = {PODS '90},
urldate = {2020-12-14}
}

@misc{zhang2016contextfree,
      title={Context-Free Path Queries on RDF Graphs}, 
      author={Xiaowang Zhang and Zhiyong Feng and Xin Wang and Guozheng Rao and Wenrui Wu},
      year={2016},
      eprint={1506.00743},
      archivePrefix={arXiv},
      primaryClass={cs.DB},
      note = {Accessed: 2020-12-14}
}
@article{social,
author = {Chaudhary, Anoop and FAISAL, ABDUL},
year = {2016},
month = {06},
pages = {},
title = {Role of graph databases in social networks},
note = {Accessed: 2020-12-14}
}
@article{URMA2015127,
title = "Source-code queries with graph databases—with application to programming language usage and evolution",
journal = "Science of Computer Programming",
volume = "97",
pages = "127 - 134",
year = "2015",
note = "Special Issue on New Ideas and Emerging Results in Understanding Software",
issn = "0167-6423",
doi = "https://doi.org/10.1016/j.scico.2013.11.010",
url = "http://www.sciencedirect.com/science/article/pii/S0167642313002943",
author = "Raoul-Gabriel Urma and Alan Mycroft",
keywords = "Programming language evolution, Source-code queries and DSLs, Graph databases",
abstract = "Program querying and analysis tools are of growing importance, and occur in two main variants. Firstly there are source-code query languages which help software engineers to explore a system, or to find code in need of refactoring as coding standards evolve. These also enable language designers to understand the practical uses of language features and idioms over a software corpus. Secondly there are program analysis tools in the style of Coverity which perform deeper program analysis searching for bugs as well as checking adherence to coding standards such as MISRA. The former class are typically implemented on top of relational or deductive databases and make ad-hoc trade-offs between scalability and the amount of source-code detail held—with consequent limitations on the expressiveness of queries. The latter class are more commercially driven and involve more ad-hoc queries over program representations, nonetheless similar pressures encourage user-visible domain-specific languages to specify analyses. We argue that a graph data model and associated query language provides a unifying conceptual model and gives efficient scalable implementation even when storing full source-code detail. It also supports overlays allowing a query DSL to pose queries at a mixture of syntax-tree, type, control-flow-graph or data-flow levels. We describe a prototype source-code query system built on top of Neo4j using its Cypher graph query language; experiments show it scales to multi-million-line programs while also storing full source-code detail.",
urldate = {2020-12-14}
}
@article{forlangpath,
author = {Barrett, Chris and Jacob, Riko and Marathe, Madhav},
year = {2000},
month = {01},
pages = {809-837},
title = {Formal-Language-Constrained Path Problems},
volume = {30},
journal = {SIAM J. Comput.},
doi = {10.1137/S0097539798337716},
note = {Accessed: 2020-12-14}
}
@article{bioinf,
author = {Sevon, Petteri and Eronen, Lauri},
year = {2008},
month = {06},
pages = {},
title = {Subgraph Queries by Context-free Grammars},
volume = {5},
journal = {Journal of Integrative Bioinformatics},
note = {Accessed: 2020-12-14}
}
@inproceedings{azimov-algo,
author = {Azimov, Rustam and Grigorev, Semyon},
title = {Context-Free Path Querying by Matrix Multiplication},
year = {2018},
isbn = {9781450356954},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3210259.3210264},
doi = {10.1145/3210259.3210264},
abstract = {Context-free path querying is a technique, which recently gains popularity in many areas, for example, graph databases, bioinformatics, static analysis, etc. In some of these areas, it is often required to query large graphs, and existing algorithms demonstrate a poor performance in this case. The generalization of matrix-based Valiant's context-free language recognition algorithm for graph case is widely considered as a recipe for efficient context-free path querying; however, no progress has been made in this direction so far.We propose the first generalization of matrix-based Valiant's algorithm for context-free path querying. Our generalization does not deliver a truly sub-cubic worst-case complexity algorithm, whose existence still remains a hard open problem in the area. On the other hand, the utilization of matrix operations (such as matrix multiplication) in the process of context-free path query evaluation makes it possible to efficiently apply a wide class of optimizations and computing techniques, such as GPGPU (General-Purpose computing on Graphics Processing Units), parallel processing, sparse matrix representation, distributed-memory computation, etc. Indeed, the evaluation on a set of conventional benchmarks shows, that our algorithm outperforms the existing ones.},
booktitle = {Proceedings of the 1st ACM SIGMOD Joint International Workshop on Graph Data Management Experiences & Systems (GRADES) and Network Data Analytics (NDA)},
articleno = {5},
numpages = {10},
keywords = {transitive closure, graph databases, matrix multiplication, GPGPU, context-free grammar, context-free path querying},
location = {Houston, Texas},
series = {GRADES-NDA '18},
note = {Accessed: 2020-12-14}
}
@inbook{tensoralgo,
author = {Orachev, Egor and Epelbaum, Ilya and Azimov, Rustam and Grigorev, Semyon},
year = {2020},
month = {08},
pages = {49-59},
title = {Context-Free Path Querying by Kronecker Product},
isbn = {978-3-030-54831-5},
doi = {10.1007/978-3-030-54832-2_6},
note = {Accessed: 2020-12-14}
}
@misc{RedisGraph,
  title = {RedisGraph - a graph database module for Redis},
  howpublished = {\url{https://oss.redislabs.com/redisgraph/}},
  note = {Accessed: 2020-12-14}
}
@misc{Graphblas,
  title = {Jeremy Kepner. GraphBLAS Mathematics - Provisional Release 1.0. ––
2017.},
  howpublished = {\url{http://www.mit.edu/\~kepner/GraphBLAS/GraphBLAS-Math-release.pdf}},
  note = {Accessed: 2020-12-14}
}
@misc{Arseniy-diploma,
  title = {Выпускная квалификационная работа "Разработка матричного алгоритма поиска
путей с контекстно-свободными
ограничениями для RedisGraph" Терехова А.К.},
  howpublished = {\url{https://se.math.spbu.ru/thesis/texts/Terehov_Arsenij_Konstantinovich_Bachelor_Thesis_2020_text.pdf}},
  note = {Accessed: 2021-10-10}
}
@article{rsm,
author = {Alur, Rajeev and Benedikt, Michael and Etessami, Kousha and Godefroid, Patrice and Reps, Thomas and Yannakakis, Mihalis},
title = {Analysis of Recursive State Machines},
year = {2005},
issue_date = {July 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {27},
number = {4},
issn = {0164-0925},
url = {https://doi.org/10.1145/1075382.1075387},
doi = {10.1145/1075382.1075387},
abstract = {Recursive state machines (RSMs) enhance the power of ordinary state machines by allowing vertices to correspond either to ordinary states or to potentially recursive invocations of other state machines. RSMs can model the control flow in sequential imperative programs containing recursive procedure calls. They can be viewed as a visual notation extending Statecharts-like hierarchical state machines, where concurrency is disallowed but recursion is allowed. They are also related to various models of pushdown systems studied in the verification and program analysis communities.After introducing RSMs and comparing their expressiveness with other models, we focus on whether verification can be efficiently performed for RSMs. Our first goal is to examine the verification of linear time properties of RSMs. We begin this study by dealing with two key components for algorithmic analysis and model checking, namely, reachability (Is a target state reachable from initial states?) and cycle detection (Is there a reachable cycle containing an accepting state?). We show that both these problems can be solved in time O(nθ2) and space O(nθ), where n is the size of the recursive machine and θ is the maximum, over all component state machines, of the minimum of the number of entries and the number of exits of each component. From this, we easily derive algorithms for linear time temporal logic model checking with the same complexity in the model. We then turn to properties in the branching time logic CTL*, and again demonstrate a bound linear in the size of the state machine, but only for the case of RSMs with a single exit node.},
journal = {ACM Trans. Program. Lang. Syst.},
month = jul,
pages = {786–818},
numpages = {33},
keywords = {model checking, context-free languages, pushdown automata, program analysis, Software verification, temporal logic, recursive state machines},
note = {Accessed: 2020-12-14}
}
@misc{Timur-diploma,
  title = {Учебная практика "Поддержка контекстно-свободных ограничений в языке Cypher" Зиннатулин Т.Р.},
  howpublished = {\url{https://oops.math.spbu.ru/SE/YearlyProjects/vesna-2020/YearlyProjects/vesna-2020/mo-2nd-course/Zinatullin-report.pdf}},
  note = {Accessed: 2020-12-14}
}

@inproceedings{memoryaliases,
author = {Verbitskaia, Ekaterina and Kirillov, Ilya and Nozkin, Ilya and Grigorev, Semyon},
title = {Parser Combinators for Context-Free Path Querying},
year = {2018},
isbn = {9781450358361},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3241653.3241655},
doi = {10.1145/3241653.3241655},
abstract = {Transparent integration of a domain-specific language for specification of context-free
path queries (CFPQs) into a general-purpose programming language as well as static
checking of errors in queries may greatly simplify the development of applications
using CFPQs. LINQ and ORM can be used for the integration, but they have issues with
flexibility: query decomposition and reusing of subqueries are a challenge. Adaptation
of parser combinators technique for paths querying may solve these problems. Conventional
parser combinators process linear input, and only the Trails library is known to apply
this technique for path querying. Trails suffers the common parser combinators issue:
it does not support left-recursive grammars and also experiences problems in cycles
handling. We demonstrate that it is possible to create general parser combinators
for CFPQ which support arbitrary context-free grammars and arbitrary input graphs.
We implement a library of such parser combinators and show that it is applicable for
realistic tasks.},
booktitle = {Proceedings of the 9th ACM SIGPLAN International Symposium on Scala},
pages = {13–23},
numpages = {11},
keywords = {Neo4j, Graph Databases, GLL, Parser Combinators, Context-Free Language Reachability, Language-Constrained Path Problem, Generalized LL, Scala, Context-Free Path Querying},
location = {St. Louis, MO, USA},
series = {Scala 2018},
note = {Accessed: 2021-11-09}
}