\input{header.tex}
\input{header2.tex}

\usepackage{ amssymb }
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{multicol, multirow}

\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{fontawesome}

\usetikzlibrary{automata, positioning, shapes,arrows}

\usepackage[caption=false]{subfig}
\usepackage{minted}
\usepackage{sidecap} 
\usepackage{fancyvrb}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{float}
\usepackage{color, colortbl}

\usepackage[noend]{algpseudocode}

\usepackage{hyperref}

\renewcommand{\labelitemii}{$ $}

\definecolor{green}{RGB}{34, 189, 65}

\theoremstyle{definition}
\newtheorem{definition}{Определение}[section]

\begin{document}
\input{title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

% \begin{abstract}
%   В курсаче не нужен
% \end{abstract}

\section*{Введение}
\input{intro.tex}

\section{Обзор}
\input{related.tex}

\section{Постановка задачи}
\label{sec:task}
\input{task.tex}

\section{Улучшение построения индекса}

Как отмечалось в разделе 1.2 в алгоритме на каждой итерации происходит пересчет произведения Кронекера и транзитивного замыкания результата. Рассмотрим предлагаемое улучшение этих этапов.

Основная идея улучшения заключается в учете лишь тех дуг, которые были добавлены на предыдущем шаге алгоритма (см. листинг 3), для этого введен набор матриц \textit{New\_Nonterm}, где каждая матрица соответствует нетерминалу. Тогда произведение Кронекера рекурсивного автомата и графа вычисляется один раз, а в цикле алгоритма происходит лишь вычисление произведения Кронекера рекурсивного автомата и графа, который состоит из дуг, добавленных на предыдущем шаге. Следующим шагом происходит транзитивное замыкание полученного произведения Кронекера. 

Далее, для того, чтобы получить транзитивное замыкание именно произведения Кронекера автомата и исходного графа, без которого шаг обновления графа невозможен, необходимо хранить матрицу $C_3$, полученную на предыдущем шаге алгоритма. Тогда получить нужное транзитивное замыкание можно, соединив дугами все вершины из $C_3$ и $M_3$, которые достигаются путем длины 1, соответственно умножив слева и справа матрицу $C_3$ на матрицу $M_3$ и сложив результаты.

\begin{algorithm}[H]
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Улучшенный алгоритм построения индекса}
\label{tensor:cfpq}
\Function{contextFreePathQuerying}{$G$, $R$}
    % Input data preparation
    \State{$M_1 \gets$ набор матриц смежности для $R$}
    \State{$M_2 \gets$ набор матриц смежности для $G$}
    % Eps-transition handling for graph
    \For{$s \in 0..dim(\mathcal{M}_1)-1$}
        \For{$S \in \textit{getNonterminals}(R,s,s)$}
            \For{$i \in 0..dim(\mathcal{M}_2)-1$}
                \State{$M_2^S[i,i] \gets \{1\}$}
            \EndFor
        \EndFor
    \EndFor
    
    \State{$C_3 \gets M_1 \otimes M_2$}
    \Comment{Вычисление произведения Кронекера}
    \State{$M_3 \gets$ пустая матрица размера $dim(C_3)$}
    \State{$New\_Nonterm \gets$ набор пустых матриц размера $dim(M_2)$ }
    \While{Набор $M_2$ изменяется}
        \State{$C_3 \  += M_1 \otimes New\_Nonterms$}
        \State{$New\_Nonterm \gets$ пустая матрица размера $dim(M_2)$}
        \State{$C_3 \gets \textit{transitiveClosure}(C_3)$}
        \State{$C_3 \ += M_3 + (M_3 \times C_3) \times M_3 + M_3 \times C_3 + C_3 \times M_3$}
        \State{$M_3 = C_3$}
        \State{$n \gets$ dim($C_3)$}
        % Add non-terminals (possibly new)
        \For{$i \in 0..n-1$}
           \For{$j \in 0..n-1$}
                \If{$C_3[i,j]$}
                    \State{$s, f \gets \textit{getStates}(C_3,i,j)$}
                    \State{$x, y \gets \textit{getCoordinates}(C_3,i,j)$}
                    \If{$\textit{getNonterminals}(R,s,f) \neq \emptyset$}
                        \For{$Nonterm \in \textit{getNonterminals}(R,s,f)$}
                            \State{$M_2^{Nonterm}[x,y] \gets \{1\}$}
                            \State{$New\_Nonterm^{Nonterm}[x,y] \gets \{1\}$}
                        \EndFor
                    \EndIf
                \EndIf
           \EndFor
        \EndFor
    \EndWhile
\State \Return $M_2$, $C_3$
\EndFunction
\end{algorithmic}
\end{algorithm}


\section{Алгоритм восстановления путей}

После вызова функции \textit{contextFreePathQuerying} из листинга 3 в наличии у пользователя оказывается информация о существовании путей между каждой парой вершин в графе. Для фактического же восстановления путей из вершины $v_s$ в вершину $v_f$ с нетерминалом $N$ на дуге $(v_s, v_f)$ предлагаются две функции, представленные на листинге 4. Входной точкой является функция $GetPaths(v_s, v_f, N)$, при вызове которой результатом будет набор путей из $v_s$ в $v_f$, где конкатенация меток каждого пути выводится из нетерминала $N$.

Для восстановления пути из указанной вершины требуется наличие рекурсивного автомата $R$, графа $G$ и результата произведения Кронекера $C_3$, полученные на последней итерации алгоритма обнаружения путей. Тогда, пользуясь тем, что матрица $C_3$ является блочной, происходит пересчет из пары $(q_s^N, v_s)$, характеризующей номер блока по строкам и номер строки в этом блоке соответственно, в $c_s$ и пары $(q_f^N, v_f)$, характеризующей номер блока по столбцам и номер столбца в этом блоке соотвественно, в $c_f$, где $q_s^N$ --- начальное состояние автомата для нетерминала N, а $q_f^N$ --- одно из конечных состояний автомата для нетерминала N, и вызывается функция $FindPaths(c_s, c_f)$. 

Далее предлагается интерпретировать $C_3$ в качестве матрицы смежности графа. В таком случае функция \textit{FindPaths} явно находит путь из $c_s$ в $c_f$, разбив его на две части. Первая часть (\textit{left}) строится из дуг вида $(c_s, k)$, а для получения второй части (\textit{right}) предлагается найти путь из $k$ в $c_f$, вызвав рекурсивно \textit{FindPaths}. Для нахождения всех возможных путей при построении \textit{left} дополнительно проверяется наличие нетерминала на рассматриваемой дуге, и в случае его обнаружения происходит вызов \textit{GetPaths}. Последним этапом соединяются все части искомых путей.

Таким образом, происходит построение всех путей между двумя заданными вершинами графа. Следует отметить, что извлечение путей может выполняться бесконечно долго при наличии циклов в графе. Для реализации предлагается ограничить глубину рекурсивных вызовов, например, количеством запрашиваемых путей или их длиной.

\begin{algorithm}[H]
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\footnotesize
\caption{Алгоритм извлечения путей}
\State{$R \gets$ Рекурсивный автомат}
\State{$G \gets $ граф}
\State{$C_3 \gets$ результат произведения Кронекера}
\State{$size\_graph \gets$ количество вершин в графе $G$}
\State{$Nontermianls \gets$ набор нетерминалов для $R$}

\Function{GetPaths}{$v_s, v_f, N$}

\State{$final\_states \gets$ финальные состояния автомата для N}
\State{$q_s^N \gets$ начальное состояние автомата для N}

\State{$result\_paths \gets$ пустое множество искомых путей}
\State{$c_s \gets q_s^N * size\_graph + v_s$}

\For{$q_f^N \in final\_states$}
\State{$c_f \gets q_f^N * size\_graph + v_f$}
\State{$result\_paths = result\_paths \cup FindPaths(c_s, c_f)$}
\EndFor
\State \Return $result\_paths$
\EndFunction

\Function{FindPaths}{$c_s, c_f$}

\If{$c_s = c_f$}
\State \Return ${}$
\EndIf
\State{$result\_paths \gets$ пустое множество найденных путей}
\State{$left \gets$ пустое множество}
\For{$k \in C_3[c_s]$}
\State{$q_i \gets \lfloor c_s / size\_graph \rfloor$}
\State{$q_j \gets \lfloor k / size\_graph \rfloor$}

\State{$v_s \gets c_s \ \ mod \ \  size\_graph$}
\State{$v_f \gets k \ \ mod \ \  size\_graph$}

\State{$labels \gets$ метки на дуге $(q_i, q_j)$}

\For{$label \in labels$}
\If{$label \in Nonterminals$}
\State{$left = left \cup GetPaths(v_s, v_f, label)$}
\Else
\State{$left = left \cup (v_s, label, v_f)$}
\EndIf
\EndFor

\State{$right \gets FindPaths(k, c_f)$}
\State{$result\_paths = result\_paths \cup left * right $}

\EndFor

\State \Return $result\_paths$

\EndFunction

\end{algorithmic}
\end{algorithm}


\section{Алгоритм построения индекса с заданным набором стартовых вершин}

В процессе работы функции \textit{contextFreePathQuerying} из листинга 3 ищутся пути между всеми вершинами. С практической точки зрения получение такой информации не всегда представляется необходимым, часто пользователю достаточно знать наличие пути из какого-то подмножества вершин. Для решения этой проблемы был разработан алгоритм, представленный на листинге 5. В качестве начальных данных принимаются, как и ранее, рекурсивный автомат и граф, но дополнительно предоставляется набор стартовых вершин графа (\textit{src\_vertices}), то есть только тех вершин, из которых требуется обнаружить пути в любые другие вершины. 

В начале (см листинг 5) начальному состоянию автомата для стартового нетерминала присваивается булева матрица, где в каждой ячейке $(i, i)$ находится 1, если $i$ находится во множестве начальных вершин графа. Всем остальным состояниям автоматов ставится в соответствие булевы матрицы, которые будут хранить информацию о текущем наборе стартовых вершин для соответствующего состояния. Далее в основном цикле алгоритма происходит построение графа, с матрицами смежности каждой метки которого и будет вычисляться произведение Кронекера. Для построения такого графа на каждой итерации предлагается следующее.

Взяв автомат для нетерминала, происходит обход всех его состояний, начиная с начального. В процессе обхода берутся все выходящие дуги-переходы (\textit{out\_edges}) из текущего состояния. Для каждой такой дуги матрица смежности исходного графа, соответствующая метке дуги-перехода, умножается на диагональную булеву матрицу, которая сопоставлена состоянию обхода. Тем самым выделяется подграф, который может быть посещен из текущего набора начальных вершин для этого состояния. Информацию о вершинах этого подграфа передается следующему состоянию, а сами подграф становится частью строящегося графа (\textit{Part\_Graph}) и обход продолжается. Тем самым на каждой итерации алгоритма обнаруживаются только пути, которые исходят из текущего стартового набора вершин графа.

После окончания работы алгоритм вернет набор матриц смежности меток исходного обновленного графа. В таком наборе матрицы для каждого нетерминала рекурсивного автомата \textit{R} будут содержать \textit{true} на месте \textit{(i,j)}, если из вершины \textit{i} в вершину \textit{j} существует искомый путь, при этом гарантируется, что \textit{i} содержалась в \textit{src\_vertices}. 

\begin{algorithm}[H]
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\footnotesize
\caption{Алгоритм построения индекса с набором стартовых вершин}
\label{tensor:cfpq}
\Function{contextFreePathQuerying}{$G$, $R$, src\_vertices:set}
    \State{$M_1 \gets$ набор матриц смежности для $R$}
    \State{$M_2 \gets$ набор матрица смежности для $G$}
    \For{$s \in 0..dim(\mathcal{M}_1)-1$}
        \For{$S \in \textit{getNonterminals}(R,s,s)$}
            \For{$i \in 0..dim(\mathcal{M}_2)-1$}
                \State{$M_2^S[i,i] \gets \{1\}$}
            \EndFor
        \EndFor
    \EndFor
    
    %\State{$size\_graph \gets$ размер матрицы смежности графа}
    \State{$boxes \gets$ автоматы для $R$}
    
    \State{$start\_state \gets$ стартовое состояние для автомата стартового нетерминала}
    \For{$src\_vertex \in src\_vertices$}
        \State{$Src^{start\_state}[src\_vertex, src\_vertex] \gets \{1\}$}
    \EndFor
    
    \While{Набор $M_2$ изменяется или $Src\_m$ изменяется}
        \State{$Part\_Graph \gets$ пустой граф}
        \For{$box \in boxes$}
            \State{$states \gets$ состояния для автомата box}
            \For{$state \in states$}
                \State{$out\_edges \gets$ пары вида (label, next state for $state$)}
                \For{$out \in out\_edges$}
                    \If{$out.label$ is nonterminal}
                        \State{$s\_state \gets$ стартовое состояние для $boxes[out.label]$}
                        \State{$Src^{s\_state} += Src^{state}$}
                    \EndIf
                    \State{$Part\_Graph^{out.label} += Src^{state} \times G^{out.label}$}
                    \State{$new\_src\_vertecies \gets$ $get\_new\_vertices(Part\_Graph^{out.label})$}
                    \For{$vertex \in new\_src\_vertecies$}
                        \State{$Src^{out.next\_state}[vertex, vertex] \gets \{1\}$}
                    \EndFor
                \EndFor
            \EndFor
        \EndFor
        
        \State{$M_3 \gets M_1 \otimes Part\_Graph$}
        \State{$C_3 \gets \textit{transitiveClosure}(M_3)$}
        
        
        
        \State{$n \gets$ dim($M_3)$}
        % Add non-terminals (possibly new)
        \For{$i \in 0..n-1$}
           \For{$j \in 0..n-1$}
                \If{$C_3[i,j]$}
                    \State{$s, f \gets \textit{getStates}(C_3,i,j)$}
                    \State{$x, y \gets \textit{getCoordinates}(C_3,i,j)$}
                    \For{$Nonterm \in \textit{getNonterminals}(R,s,f)$}
                        \State{$M_2^{Nonterm}[x,y] \gets \{1\}$}
                    \EndFor
                \EndIf
           \EndFor
        \EndFor
    \EndWhile
\State \Return $M_2$
\EndFunction

\Function{get\_new\_vertices}{$M$}
    \State{$A \gets \textit{Пустой набор вершиин}$}
    \ForAll{$(v,to) \in V^2 \mid M[v,to] = true$}
        \State{$A \gets to$}
    \EndFor
    \State \Return A
\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Детали реализаций}
Для реализации полученных алгоритмов была разработана архитектура, представленная на рисунке 1.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{img/pyalgo.pdf}
    \caption{Архитектура реализаций алгоритмов}
\end{figure}

Полученная архитектура \textit{CFPQ\_PyAlgo} состоит из трёх модулей: \textit{Graph}, \textit{Grammar} и \textit{Problems}. 

Модуль \textit{Graph} предназначен для представления графов и их загрузки в качестве входных данных. Модуль \textit{Grammar} реализует хранение и загрузку грамматики в виде ОНФХ, а также рекурсивного автомата. Оба модуля поддерживают данные из \textit{CFPQ\_Data}.

Модуль \textit{Problems} разбит на несколько частей. Создание каждой части мотивируется решаемой задачей. Все такие части содержат интерфейс задачи, который реализуют алгоритмы с использованием библиотеки \textit{PyGraphBlas}. В качестве входных данных реализации принимают путь до графа и путь до контекстно-свободной грамматики. Далее каждая конкретная реализация алгоритма выбирает нужные представления графа и грамматики из модулей \textit{Graph} и \textit{Grammar}, соответственно.

Разработанные алгоритмы из разделов 3 и 4 представлены в части \textit{AllPaths}, а из раздела 5 --- в \textit{MultipleSource}, исходный код которых находится в репозитории \textit{CFPQ\_PyAlgo}\footnote{Репозиторий \textit{CFPQ\_PyAlgo}: https://github.com/JetBrains-Research/CFPQ\_PyAlgo Дата посещения 13.05.2021}. Для предложенных реализаций написаны тесты на некоторые варианты входных данных и базовая документация. Репозиторий оснащен системой сборки и запуска тестов, а также в нем находятся скрипты для замеров производительности, результаты которых представлены в следующем разделе.

\section{Замеры производительности}
Рассмотрим результаты замеров производительности полученных реализаций. Для этого сначала опишем выбранные данные и окружение для постановки экспериментов.

\subsection{Окружение и данные для экспериментов}

Для постановки экспериментов над реализациями был использован ПК с операционной системой Ubuntu 20.04 и конфигурацией: Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz CPU, DDR4 64 Gb RAM.

Из набора данных CFPQ\_Data были взяты графы следующих классов:
\begin{itemize}
    \item RDF --- реальные биологические данные;
    \item MemoryAliases --- графы анализа указателей языка Си. Обладают более сложной структурой в отличии от графов класса RDF.
\end{itemize}

Таким образом были выбраны графы, представленные в таблице 1.

\begin{table}[H]
\begin{center}
{

%\rowcolors{2}{black!2}{black!10}
\begin{tabular}{|l|c|c|}
\hline
Graph          & \#V       & \#E        \\
\hline
\hline
eclass\_514en  & 239 111    & 523 727   \\
enzyme         & 48 815     & 109 695   \\
geospecies     & 450 609    & 2 201 532 \\
go             & 272 770    & 534 311   \\
go-hierarchy   & 45 007     & 980 218   \\
taxonomy       & 5 728 398  & 14 922 125\\
\hline
arch           & 3 448 422  & 5 940 484 \\
crypto         & 3 464 970  & 5 976 774 \\
drivers        & 4 273 803  & 7 415 538 \\
fs             & 4 177 416  & 7 218 746 \\
\hline
\end{tabular}
}
\end{center}
\caption{Графы}
\end{table}
В качестве грамматик были взяты следующие:
\begin{itemize}
    \item $G_1: S \to \overline{sco} \ \ S \ \ sco\ \ | \ \ \overline{type} \ \ S \ \ type \ \ | \ \ \overline{sco} \ \ sco \ \ | \ \ \overline{type} \ \ type$
    \item $G_2: S \to \overline{sco} \ \ S \ \ sco \ \ | \ \ sco$
    \item $Geo: S \to bt \ \ S \ \ \overline{bt} \ \ | \ \ bt \ \ \overline{bt}$
    \item $MA:$
    \begin{itemize}
        \item $S \to \overline{d} \ \ V \ \ d$
        \item $V \to (S?\overline{a})^{*}S?(aS?)^{*}$
    \end{itemize}
\end{itemize}
Где $\overline{x}$ обозначает ребро обратное ребру с меткой $x$ в графе. Количество терминалов из выбранных грамматик, соответствующие меткам в графах, приведено в таблице 2.
\begin{table}[H]
\begin{center}
{

%\rowcolors{2}{black!2}{black!10}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Graph          & \#sco & \#type &\#bt & \#a  & \#d \\
\hline
\hline
eclass\_514en  & 90 512    & 72 517    &        ---        & ---  & --- \\
enzyme         & 8 163     & 14 989    &        ---        & ---  & --- \\
geospecies     & 0         & 89 062    &        20 867     & ---  & --- \\
go             & 90 512    & 58 483    &        ---        & ---  & --- \\
go-hierarchy   & 490 109   & 0         &        ---        & ---  & --- \\
taxonomy       & 2 112 637 & 2 508 635 &        ---        & ---  & --- \\
\hline
arch           &      ---     &  ---   &        ---        & 671 295 & 2 298 947 \\
crypto         &      ---     &  ---   &        ---        & 678 408 & 2 309 979 \\
drivers        &      ---     &  ---   &        ---        & 858 568 & 2 849 201 \\
fs             &      ---     &  ---   &        ---        & 824 430 & 2 784 943 \\
\hline
\end{tabular}
}
\end{center}
\caption{Количество терминалов из выбранных грамматик, соответствующих меткам в графах}
\end{table}

\subsection{Эксперименты над улучшением алгоритма построения индекса}

Сравнения реализации улучшения, предложенного в разделе 3, производились с реализацией базового алгоритма, основанного на произведении Кронекера, использующей тот же набор технологий и ПК для проведения экспериментов. 


В ходе проведения экспериментов было произведено 5 запусков с каждым графом и каждой грамматикой. В конце бралось среднее значение из каждой выборки. Таким образом результаты измерений представлены с $\pm \Delta = \pm 0,06$ сек точностью оценки при доверительной вероятности 0.95.

\begin{table}[H]
    \begin{center}
    %\rowcolors{4}{black!2}{black!10}
    \begin{tabular}{| l | c | c | c | c | c | c | c | c |}
      \hline

      \multirow{2}{*}{Name}  & \multicolumn{2}{c|}{$G_1$} & \multicolumn{2}{c|}{$G_2$} & \multicolumn{2}{c|}{\textit{Geo}} & \multicolumn{2}{c|}{\textit{MA}}\\
      \cline{2-9}
                      & Tns2   & Tns1   & Tns2 & Tns1 & Tns2  & Tns1  & Tns2    & Tns1 \\
      \hline
      \hline
      eclass\_514en   & 0.24   & 0.25   & 0.25 & 0.26 & ---   & ---   & ---     & ---\\
      enzyme          & 0.03   & 0.04   & 0.02 & 0.04 & ---   & ---   & ---     & ---\\
      geospecies      & 0.08   & 0.09   & $<0.01$ & 0.01 & 26.12 & 34.12 & ---  & ---\\
      go-hierarchy    & 0.16   & 0.19   & 0.23 & 0.29 & ---   & ---   & ---     & ---\\
      go              & 1.56   & 1.68   & 1.21 & 1.37 & ---   & ---   & ---     & ---\\
      pathways        & 0.01   & 0.02   & 0.01 & 0.01 & ---   & ---   & ---     & ---\\
      taxonomy        & 4.81   & 5.37   & 3.75 & 3.81 & ---   & ---   & ---     & ---\\
      \hline
      arch            & ---    & ---    & ---  & ---  & ---   & ---   & 262.45  & 390.05  \\
      crypto          & ---    & ---    & ---  & ---  & ---   & ---   & 267.52  & 395.98  \\
      drivers         & ---    & ---    & ---  & ---  & ---   & ---   & 1309.57 & 2114.16 \\
      fs              & ---    & ---    & ---  & ---  & ---   & ---   & 470.49  & 745.97  \\
      \hline
    \end{tabular}
    \end{center}
    \caption{Результаты экспериментов над улучшением построения индекса, время в секундах}
  \end{table}

В таблице 3 продемонстрировано время в секундах работы алгоритмов над графами в зависимости от грамматик. Знак "---" означает неприменимость грамматики к графу. Tns2 --- результаты алгоритма с улучшением, Tns1 --- результаты алгоритма без улучшения.

Таким образом, наблюдается всюду положительный результат. А именно, для графов типа RDF уменьшение времени выполнения составило до 23\%, а для графов MemoryAliases --- до 38\%. Особо выразительный выигрыш алгоритма с улучшением получился на графах типа MemoryAliases, так как в виду их сложной структуры происходит большое число действий при транзитивном замыкании в базовой версии алгоритма, а предложенное улучшение позволяет уменьшить число таких операций.

\subsection{Эксперименты над алгоритмом извлечения путей}

Для реализации предложенного алгоритма извлечения путей в разделе 4 было выбрано ограничение на глубину рекурсии в виде длины пути. Таким образом, к процедуре \textit{GetPaths} добавляется ещё один аргумент, который характеризует ограничение на длину пути, и в таком случае результатом будет набор путей длины меньше заданной этим аргументом.

В ходе эксперимента был выбран из таблицы 1 граф \textit{eclass\_514en} и грамматика $G_1$ и происходило восстановление путей из всех пар вершин, между которыми был обнаружен путь алгоритмом построения индекса, с ограничением на длину в 20 и 50. Сравнение происходит с алгоритмом, основанным на матричном умножении.

Таким образом были получены результаты, изображенные на рисунках 2 и 4, для предложенного алгоритма.
\begin{figure}[!]
\begin{minipage}[h]{0.49\linewidth}
\center{\includegraphics[width=8cm]{img/tensor_eclass_514en_20_small.pdf}}
\caption{Результаты эксперимента над извлечением путей Tns с ограничением по длине 20}
\end{minipage}
\hfill
\begin{minipage}[h]{0.49\linewidth}
\center{\includegraphics[width=8cm]{img/allMatr_eclass_514en_10_small.pdf}}
\caption{Результаты эксперимента над извлечением путей Mtx с ограничением по длине 20}
\end{minipage}
\end{figure}

На графиках приведены распределение времени для пяти самых часто встречающихся количеств найденных путей. Аналогичные результаты для алгоритма, основанного на матричном умножении, приведены на рисунках 3 и 5.

\begin{figure}[h!]
\begin{minipage}[h]{0.49\linewidth}
\center{\includegraphics[width=8cm]{img/tensor_eclass_514en_50_small.pdf}}
\caption{Результаты эксперимента над извлечением путей Tns с ограничением по длине 50}
\end{minipage}
\hfill
\begin{minipage}[h]{0.49\linewidth}
\center{\includegraphics[width=8cm]{img/allMatr_eclass_514en_20_small.pdf}}
\caption{Результаты эксперимента над извлечением путей Mtx с ограничением по длине 50}
\end{minipage}
\end{figure}

На рисунках 2 и 4 наблюдается незначительный прирост времени выполнения при увеличении ограничения на длину путей.

Таким образом предложенный алгоритм медленнее аналога более чем в 100 раз по времени выполнения, так как в процессе обнаружения путей алгоритм, основанный на матричном умножении, строит структуру, которая явно хранит вершины, являющиеся частями искомых путей, в то время как для алгоритма, основанного на произведении Кронекера, приходится обходить матрицу смежности $C_3$.

\subsection{Эксперименты над алгоритмом обнаружения путей с заданным набором стартовых вершин}

Для постановки экспериментов над реализацией предложенного алгоритма в разделе 5 были выбраны из таблицы 1 графы \textit{go-hierarchy} и \textit{eclass\_514en} и грамматика $G_1$. Для каждого графа множество его вершин было разбито на непересекающиеся множества фиксированного размера. Далее производился запуск для каждого такого множества в качестве стартового набора вершин. Полученные результаты представлены на рисунках 6 и 7 синим цветом. Штрихом на диаграммах представлена медиана.

\begin{figure}[h]
\begin{minipage}[h]{0.49\linewidth}
\center{\includegraphics[width=8cm]{img/ms_all_eclass_514en_new.pdf}}
\caption{Результаты экспериментов над алгоритмом с начальном мн-вом вершин на графе \textit{eclass\_514en}}
\end{minipage}
\hfill
\begin{minipage}[h]{0.49\linewidth}
\center{\includegraphics[width=8cm]{img/ms_all_go-hierarchy_new.pdf}}
\caption{Результаты экспериментов над алгоритмом с начальном мн-вом вершин на графе \textit{go-hierarchy}}
\end{minipage}
\end{figure}

Сравнение производилось с аналогичным алгоритмом через матричное умножение. Результат работы аналога представлен на рисунках оранжевым цветом.

Таким образом для взятых графов алгоритм через произведение Кронекера, сравним с аналогом на множествах начальных вершин размером не превосходящих 1000. Начиная с размера начального множества вершин 5000, алгоритм через произведение Кронекера демонстрирует меньшее время работы. Однако видно, что цель создания алгоритма с точки зрения времени выполнения оправдывается только при размере начального множества вершин меньше 1000. Так как в таблице 3 указано, что полную информацию о достижимости для графа \textit{eclass\_514en} можно получить за 0.24 с., а \textit{go-hierarchy} --- за 0.16 с.



% У заключения нет номера главы
\section*{Заключение}
В ходе работы были выполнены следующие задачи.
\begin{enumerate}
    \item Улучшен алгоритм построения индекса с использованием динамического пересчета некоторых шагов алгоритма и реализовано полученное улучшение.
    \item Разработан и реализован алгоритм извлечения путей по результату работы алгоритма построения индекса.
    \item Разработан и реализован алгоритм построения индекса с фиксированным набором стартовых вершин.
    \item Произведено экспериментальное исследование производительности реализаций. Полученное улучшение алгоритма поиска путей демонстрирует уменьшение времени до 38 \% по сравнению с версией без улучшения. Разработанный алгоритм с набором стартовых вершин быстрее существующего аналога. Однако алгоритм извлечения путей оказался медленнее до 100 раз того же аналога ввиду более сложно устроенных структур необходимых в процессе его работы.
\end{enumerate}

Также результат был изложен в статье "Context-Free Path Querying with All-Path Semantics by Matrix Multiplication", которая принята на конференцию GRADES-NDA 2021.

Реализации представлены в репозитории: \href{https://github.com/JetBrains-Research/CFPQ\_PyAlgo}{https://github.com/JetBrains-Research/CFPQ\_PyAlgo}.

% \nocite{*}
\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{vkr}
\end{document}
