\label{sec:relatedworks}
Рассмотрим алгоритмы, решающие задачу поиска путей с контекстно-свободными ограничениями с помощью операций линейной алгебры, в несколько этапов. Первым этапом приведем определения, встречающиеся в их описании. Вторым этапом рассмотрим алгоритм, основанный на произведении Кронекера, и алгоритм, основанный на матричном умножении, и сравним их, выделяя проблемы, которые лягут в основу работы. Последним этапом выберем инструмент для оценки производительности решений указанных проблем.
\subsection{Базовые определения}

Следующее определение формально описывает структуру представления грамматики для алгоритма, основанного на произведении Кронекера.
\theoremstyle{definition}
\begin{definition}
Рекурсивный автомат \cite{rec} над конечным алфавитом $\Sigma$ есть набор $(M,m,\{C_i\}_{i \in M})$, где 

\begin{itemize}
    \item $M$ конечное множество меток,
    \item $m \in M$ начальная метка,
    \item $ \{C_i\}_{i \in M} $ множество \textit{конечных автоматов},
          где $C_i=(\Sigma \cup M, Q_i,q_i^0,F_i,\delta_i)$:
    \begin{itemize}
        \item $\Sigma \cup M$ множество символов, $\Sigma \cap M = \emptyset$,
        \item $Q_i$ конечное множество состояний,
              где $Q_i \cap Q_j = \emptyset, \forall i \neq j$,
        \item $q_i^0$ начальное состояние $C_i$,
        \item $F_i$ множество финальных состояний $C_i$, где $F_i \subseteq Q_i$,
        \item $\delta_i$ функция переходов $C_i$,
              где $\delta_i: Q_i \times (\Sigma \cup M)
              \to Q_i$.
    \end{itemize}
\end{itemize}
\end{definition}

\begin{definition}
Пусть $\mathcal{G}$ = $( \Sigma, $N$, $P$, $S$ )$ --- контекстно-свободная грамматика, тогда $\mathcal{G}$ находится в \textbf{ослабленной нормальной форме Хомского} (ОНФХ), если содержит только правила вида:
\begin{itemize}
    \item $A \rightarrow BC$, где $A$, $B$, $C \in N$
    \item $A \rightarrow a$, где $A \in N$, $a \in \Sigma$
    \item $A \rightarrow \varepsilon$, где $A \in N$
\end{itemize}
\end{definition}

Определение ОНФХ отличается от нормальной формы Хомского наличием правил вида $A \rightarrow \varepsilon$, где А --- любой нетерминал, то есть А не обязательно является стартовым, а также допущением использовать стартовый нетерминал в правых частях правил при наличии правила вида $S \to \varepsilon$.

\begin{definition}
Пусть $G$ --- помеченный граф с n вершинами, $M$ --- матрица смежности $G$ и $L$ --- множество различных меток на дугах графа $G$, тогда матрицей смежности для $l \in L$ называется матрица $M^l$ размером $n \times n$, где 
\begin{equation*}
M^l[i, j] = \begin{cases} true \text{, между вершинами i и j существует дуга с меткой } $l$\\ false \text{, иначе} \end{cases}    
\end{equation*} 
\end{definition}

\subsection{Алгоритм, основанный на произведении Кронекера}

В статье~\cite{10.1007/978-3-030-54832-2_6} был представлен алгоритм, основанный на произведении Кронекера, для поиска путей между всеми парами вершин, именуемый алгоритмом построения индекса, то есть результатом работы является структура данных, указывающая между какими парами есть требуемый путь. Представленный алгоритм основан на матричных операциях и использует рекурсивный автомат.

Алгоритм (листинг 2) принимает граф $G$ и рекурсивный автомат $R$. Основная идея заключается в использовании произведения Кронекера, как инструмента для пересечения двух автоматов. В качестве второго автомата в алгоритме предлагается выбрать граф $G$. Такой выбор является корректным, так как каждую вершину можно считать состоянием, а дуги --- переходами.

На начальном этапе (строки 2-3) алгоритма берутся матрицы смежности для всех меток графа и автомата по определению 1.3. Стоит отметить, что определение 1.3 дано для графа, но аналогичное определение можно ввести и для рекурсивного автомата. Дополнительно (строки 4-5) для каждого нетерминала из $R$ создается пустая матрица смежности в наборе $M_2$, который соответствует графу $G$.

Первым шагом (строки 6-9) проверяется наличие состояний в автомате $R$, которые одновременно являются стартовыми и конечными, то есть проверяется наличие $\varepsilon$ правил для грамматики. При наличии таковых из каждой вершины в неё же есть искомый путь.

Основной цикл (строки 10-20) алгоритма выполняется до тех пор пока набор матриц смежности для графа меняется. Первым шагом цикла происходит вычисление произведения Кронекера (строка 11), тем самым создавая матрицу смежности нового автомата. Далее результат транзитивно замыкается для получения информации о достижимости состояний в полученном автомате. И последним шагом (строки 14-20) происходит обновление при помощи операций, представленных на листинге 1, матрицы графа, которая соответствует нетерминалу, конечное состояние автомата которого достижимо из начального состояния.

%Алгоритм (листинг 2) принимает граф G и рекурсивный автомат R. Операции выполняются с булевской декомпозицией матриц смежности входных данных. Такой вид представления требует соответствующее переопределение операций, то есть операцией умножения будет являться логическое И, а операцией сложения --- логическое ИЛИ. Алгоритм состоит из трёх последовательных операций: произведение Кронекера, транзитивное замыкание и обновление. Произведение Кронекера пересекает два автомата (R и G), его результат транзитивно замыкается и на шаге обновления добавляются дуги с метками в виде соответствующих нетерминалов. Шаги алгоритма повторяются пока граф изменяется. На каждой итерации находятся пути длиной (количество дуг) на один больше чем на предыдущей.

%Алгоритм построения индекса, основанный на тензорном произведении, был представлен в статье~\cite{10.1007/978-3-030-54832-2_6}, который в рамках работы для краткости будет называться просто алгоритмом, основанным на Кронекеровом произведении. Он основан на матричных операциях, что позволяет использовать при его реализации высокопроизводительные библиотеки линейной алгебры. А также данный алгоритм использует рекурсивный автомат для представления грамматки, что дает ему преимущество по сравенению с алгоритмом~\cite{alg_matrix}, основанным на матричном умножении, так как второй принимает на вход грамматику лишь в ОНФХ, что приводит к её разрастанию, и, как следствие, отрицательно сказывается на производительности. Однако в процессе работы алгоритма, основанного на Кронекеровом произведении, а именно в результате Кронекерова произведения, возникают матрицы больших размеров. Например, если указанным образом перемножить одну матрицу размером $m \times p$ и вторую матрицу $n \times q$, то в результате получается матрица $mn \times pq$, что может отрицательно сказаться на производительности.

%Рассмотрим алгоритм подробнее. Пусть (см. листинг 2) $M_{1}$ --- набор матриц смежности меток для рекурсивного автомата, а $M_{2}$ --- набор матриц смежности для $\mathcal{G}$. При таком подходе каждой метке соответствует булева матрица смежности, то есть для какой-то метки A $M_{1}[A][i,j] = true$ означает наличие ребра из i в j с меткой A. Такой вид представления требует соответствующее переопределение операций, то есть операцией умножения будет являться логическое И, а операцией сложения --- логическое ИЛИ. Перед началом основного цикла алгоритма происходит постановка дуг среди вершин, среди которых существует путь длины 0. На первом же шаге основного цикла вычисляется Кронекерово произведение изначального автомата и графа, складывая все результаты Кронекерова произведения булевых матриц смежности из $M_{1}$ и $M_{2}$, соответствующих одним меткам. После чего результат транзитивно замыкается. Следующим шагом, обходя матрицу транзитивного замыкания, проверяется наличие ребра и принадлежность начальной и конечной вершин стартовому и конечному состоянию рекурсивного автомата, для этого на листинге 1 приведены вспомогательные функции. При выполнении условия алгоритм добавляет нетерминал/нетерминалы, соответствующие стартовому и конечному состоянию автомата, в ячейку матрицы из $M_{2}$, что свидетельствует о существовании пути, объединение меток которого выводится из указанного нетерминала, между индексами (вершинами) этой ячейки. Данные шаги алгоритма повторяются, пока одна из матриц в $M_{2}$ изменяется. Таким образом, за каждую итерацию $i$ получаются пути, выводимые из грамматики за $i$ шагов. Результатом работы алгоритма является набор матриц $M_{2}$.

\begin{algorithm}[H]
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Вспомогательные функции}
\label{tensor:cfpq:help}
\Function{getStates}{$M_1, i, j$}
    \State{$r \gets dim(M_1)$}
    \State \Return{$\left\lfloor{i / r}\right\rfloor, \left\lfloor{j / r}\right\rfloor$}
\EndFunction
\Function{getCoordinates}{$M_2, i, j$}
    \State{$n \gets dim(M_2)$}
    \State \Return{$i \bmod n, j \bmod n$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Алгоритм, основанный на произведении Кронекера}
\label{tensor:cfpq}
\Function{contextFreePathQuerying}{$G$, $R$}
    % Input data preparation
    \State{$M_1 \gets$ набор матриц смежности для $R$}
    \State{$M_2 \gets$ набор матрица смежности для $G$}
    
    \ForAll{$nonterminals \in R$}
        \State{$M_2 = M_2 \cup \{\text{пустая матрица}\}$}
    \EndFor
    
    % Eps-transition handling for graph
    \For{$s \in 0..dim(\mathcal{M}_1)-1$}
        \For{$S \in \textit{getNonterminals}(R,s,s)$}
            \For{$i \in 0..dim(\mathcal{M}_2)-1$}
                \State{$M_2^S[i,i] \gets \{1\}$}
            \EndFor
        \EndFor
    \EndFor
    \While{Набор $M_2$ изменяется}
        \State{$M_3 \gets M_1 \otimes M_2$}
        \State{$C_3 \gets \textit{transitiveClosure}(M_3)$}
        \State{$n \gets$ dim($M_3)$}
        % Add non-terminals (possibly new)
        \For{$i \in 0..n-1$}
           \For{$j \in 0..n-1$}
                \If{$C_3[i,j]$}
                    \State{$s, f \gets \textit{getStates}(C_3,i,j)$}
                    \State{$x, y \gets \textit{getCoordinates}(C_3,i,j)$}
                    \For{$Nonterm \in \textit{getNonterminals}(R,s,f)$}
                        \State{$M_2^{Nonterm}[x,y] \gets \{1\}$}
                    \EndFor
                \EndIf
           \EndFor
        \EndFor
    \EndWhile
\State \Return $M_2$
\EndFunction
\end{algorithmic}
\end{algorithm}

Из рассмотренного видно, что на каждой итерации основного цикла происходит пересчет шагов, связанных с вычислениями произведения Кронекера и транзитивного замыкания. Хотя алгоритм обладает монотонностью, то есть добавленные дуги, свидетельствующие о существовании пути, никогда не удаляются из графа. То есть в пересчете заново указанных шагов нет никакой необходимости. Таким образом, появляется потребность в улучшении алгоритма построения индекса.

\subsection{Алгоритм, основанный на матричном умножении}

Вторым алгоритмом, основанным на операциях линейной алгебре, является алгоритм, основанный на матричном умножении, предложенный в статье~\cite{alg_matrix}. В качестве входных данных алгоритм принимает грамматику в ОНФХ и граф, который представлен также в виде набора булевых матриц смежности для каждой метки.

Основная идея алгоритма заключается в рассмотрении отдельно правил, где в правой части находится один терминал, вида $A \rightarrow a$, и правил, где в правой части находятся два нетерминала, вида $A \rightarrow BC$. Для первого типа правил о наличии искомого пути говорит наличие дуги с меткой в виде терминала $a$. Для второго типа правил предлагается умножать матрицы смежности, соответствующие двум нетерминалам $B$ и $C$. Такая операция позволяет соединить дугой вершины, которые достижимы путем, состоящим из 2 дуг, первая из которых с меткой $B$, а вторая --- с $C$, тем самым гарантируя обнаружение путей, выводимых из нетерминала $A$.

Было предложено множество модификаций этого алгоритма, покрывающие разнообразные варианты практического использования. Например, в статье Арсения Терехова и др.~\cite{ms-matrix} была предложена модификация, позволяющая искать пути, исходящих из фиксированного набора вершин.

\subsection{Сравнение алгоритмов, основанных на операциях линейной алгебры}

В предыдущих разделах были рассмотрены алгоритм, основанный на произведении Кронекера, и алгоритм, основанный на матричном умножении, реализации которых далее в работе будут обозначены Tns и Mtx, соответственно. Теперь рассмотрим их достоинства и недостатки перед друг другом.

Недостатком алгоритма, основанного на матричном умножении, является представление грамматики в виде ОНФХ, так как это влечёт к увеличению количества правил, что может отрицательно сказаться на производительности. В свою очередь алгоритм, основанный на произведении Кронекера, использует рекурсивный автомат, что является его преимуществом перед аналогом, так как позволяет избежать необходимости преобразовывать исходную грамматику. Однако алгоритм, основанный на произведении Кронекера, оперирует в процессе работы матрицами больших размеров, а именно в результате выполнения произведения Кронекера, взяв матрицу размера $m \times n$ в качестве второго операнда, получается матрица, количество строк и столбцов которой равно количеству строк и столбцов первого операнда увеличенных в $m$ и $n$ раз соответственно. 

Таким образом, оба алгоритма основаны на операциях линейной алгебре, что позволяет использовать высокопроизводительные библиотеки при их реализации. Однако алгоритм, основанный на произведении Кронекера, использует рекурсивный автомат, тем самым не увеличивает количество продукций исходной грамматики, что говорит о его конкурентоспособности перед алгоритмом, основанным на матричном умножении.

Но также важным достоинством алгоритма, основанного на матричном умножении, перед аналогом является наличие модификаций для извлечения путей и обнаружения путей, исходящих из фиксированного набора вершиин, так как их существование дает возможность полноценного использования алгоритма, например, в графовых базах данных. Таким образом, появляется потребность в разработке указанных модификаций для алгоритма, основанного на произведении Кронекера.

%Основная идея алгоритма заключается в интерпретации умножения матриц следующим образом. Рассмотрим умножение двух матриц: $C = A\times B$. Пусть эти две матрицы являются булевыми матрицами смежности. В таком случае, если переопределить операции умножения и сложения самих элементов матриц, а именно, операцию сложения заменить на логическое ИЛИ, а операцию умножения --- на логическое И, то полученная матрица $C$ будет булевой матрицей смежности графа, имеющего ребро $(i,j)$, если вершина i в A и вершина j в B имеют общую соседнюю вершину. Используя эту идею алгоритм, основанный на матричном умножении, обнаруживает искомые пути.



\subsection{Библиотека SuiteSparse}

Для реализации полученных алгоритмов и последующей оценки их производительности был выбран API GraphBLAS\footnote{Репозиторий проекта GraphBLAS: https://github.com/GraphBLAS Дата посещения: 25.12.2020}, так как на данный момент является единственным API для работы с графами на языке линейной алгебры.

Реализацию основных концепций API GraphBLAS предоставляют библиотеки GBTL~\cite{doi:10.1177/1094342011403516}, CombBLAS\footnote{Репозиторий проекта CombBLAS: https://github.com/PASSIONLab/CombBLAS Дата посещения: 25.12.2020}, GraphBLAST~\cite{yang2020graphblast} и SuiteSparse~\cite{8916550}. Для выбора конкретной библиотеки необходимо наличие в ней операций произведения Кронекера, сложения и умножения матриц. Всеми указанными операциями обладают лишь библиотеки GBTL и SuiteSparse. Также достоинством этих библиотек является наличие оберток на языке Python, что облегчает постановку экспериментов. Однако, обертка\footnote{Репозиторий проекта: https://github.com/jessecoleman/gbtl-python-bindings Дата посещения: 25.12.2020} для GBTL на данный момент не поддерживает операцию произведения Кронекера, что приводит к выбору SuiteSparse и, в частности, обертки pygraphblas\footnote{Репозиторий проекта pygraphblas: https://github.com/michelp/pygraphblas Дата посещения: 12.12.2020} для неё.

К достоинствам SuiteSparse также можно отнести использование многопоточности и оптимизаций для разных видов представления векторов и матриц, в том числе учитывается свойство разреженности при хранении и выполнении операций над ними.

Таким образом, для реализации предложенных алгоритмов использовалась библиотека SuiteSparse.