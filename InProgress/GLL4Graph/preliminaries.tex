\section{Preliminaries}

%In this section we introduce basic definitions and notations for graphs, context-free grammars and used parsing algorithm.

We use a directed edge-labelled graph as a data model. We denote a graph as $D=\langle V,E,L \rangle$, where $V$ is a finite set of vertices, $E \subseteq V \times L \times V$ is a set of edges, and $L$ is a set of edge labels. A path $\pi$ in a graph $D$ is a sequence of edges: $u \xrightarrow{l_0} \ldots \xrightarrow{l_m} v$. We denote a path between vertices $u$ and $v$ as $u\pi v$. Function $\omega$ maps a path to a word by concatenating the labels of its edges: $\omega(\pi) = \omega(u \xrightarrow{l_0} \ldots \xrightarrow{l_m} v) = l_0\ldots l_m .$

A context-free grammar is a 4-tuple $G=\langle \Sigma, N, P, S\rangle$, where $\Sigma$ is a finite set of terminals, $N$ is a finite set of nonterminals, $S \in N$ is the start nonterminal, and $P$ is a set of productions. Each production has the following form: $M \to w$, where $M \in N$ is a left-hand side of production, and $w \in (\Sigma \cup N )^*$ is a right-hand side of production. $S \to w_1 \mid w_2$ is used instead of $S \to w_1; S \to w_2$. Some example grammars are presented in equations~\ref{eqn:g_1},~\ref{eqn:g_2}, and~\ref{eqn:geo}. A derivation step is a production application: having a sequence of form $w_1Bw_2$, where $B \in N$ and $w_1, w_2 \in (\Sigma \cup N)^*$, and a production $B \to w_3$, one gets a sequence $w_1w_3w_2$, by replacing the left-hand side of the production with its right-hand side. A word $w$ is derivable in a grammar if there is a sequence of derivation steps such that the initial sequence is the start nonterminal of the grammar and $w$ is a final sequence. The language specified by the grammar $G$ (denoted $\mathcal{L}(G)$) is a set of words derivable from the start nonterminal of the given grammar.

We can formulate a set of problems for the graph $D$ and the context-free grammar $G$: 
\begin{align}
R &= \{(u,v) \mid \text{exists a path } u\pi v \text{ in } D, \omega(\pi) \in \mathcal{L}(G)  \} \label{eqn:all_pairs_reachability}
\\
Q &= \{\pi \mid \text{exists a path } u\pi v \text{ in } D, \omega(\pi) \in \mathcal{L}(G)  \} \label{eqn:all_pairs_all_paths}
\\
R(I) &= \{(u,v) \mid \text{exists a path } u\pi v \text{ in } D, u \in I, \omega(\pi) \in \mathcal{L}(G)  \} \label{eqn:multiple_source_reachability}
\\
Q(I) &= \{\pi \mid \text{exists a path } u\pi v \text{ in } D, u \in I, \omega(\pi) \in \mathcal{L}(G)  \} \label{eqn:multiple_source_all_paths}
\end{align}

Here~\ref{eqn:all_pairs_reachability} is the \textit{all pairs reachability problem},~\ref{eqn:all_pairs_all_paths} is the \textit{all pairs all paths problem}. In~\ref{eqn:multiple_source_reachability} and~\ref{eqn:multiple_source_all_paths}, the additional parameter $I$ denotes the set of start vertices. Thus~\ref{eqn:multiple_source_reachability} and~\ref{eqn:multiple_source_all_paths} --- are the \textit{multiple source reachability} and the \textit{multiple source all paths} problems respectively. Note, that for the \textit{all paths} problems, the result $Q$ can be an infinite set. Typically, the algorithms for these problems build a finite structure which contains all paths of the interest, not the explicit set of paths.                                                                                                                                                                                                                   

Our solution is based on the generalized LL parsing algorithm~\cite{SCOTT2010177} which was shown to generalize well to graph processing~\cite{Grigorev:2017:CPQ:3166094.3166104}. We use Iguana project, which provides the Java implementation of a modified GLL algorithm~\cite{10.1007/978-3-662-46663-6_5}, as a base for our solution. As a result of parsing, GLL constructs a Shared Packed Parse Forest (SPPF) --- a special data structure which represents all possible derivations of the input in a compressed form. It was shown in~\cite{Grigorev:2017:CPQ:3166094.3166104} that SPPF can be naturally used as a finite representation of the \textit{all paths} problems~\ref{eqn:all_pairs_all_paths} and~\ref{eqn:multiple_source_all_paths}.