@inproceedings{bradford2007quickest,
  author = {Bradford, Phillip G.},
  title = {Quickest Path Distances on Context-Free Labeled Graphs},
  year = {2007},
  isbn = {9789606766251},
  publisher = {World Scientific and Engineering Academy and Society (WSEAS)},
  address = {Stevens Point, Wisconsin, USA},
  booktitle = {Proceedings of the 6th WSEAS International Conference on Information Security and Privacy},
  pages = {22--29},
  numpages = {8},
  keywords = {quickest path, labeled graph, dynamic programming, context-free grammar, algorithm design},
  location = {Tenerife, Spain},
  series = {ISP'07}
}

@article{ward2010complexity,
  author = {Ward, Charles B. and Wiegand, Nathan M.},
  title = {Complexity Results on Labeled Shortest Path Problems from Wireless Routing Metrics},
  year = {2010},
  issue_date = {February 2010},
  publisher = {Elsevier North-Holland, Inc.},
  address = {USA},
  volume = {54},
  number = {2},
  issn = {1389-1286},
  url = {https://doi.org/10.1016/j.comnet.2009.04.012},
  doi = {10.1016/j.comnet.2009.04.012},
  journal = {Comput. Netw.},
  month = feb,
  pages = {208--217},
  numpages = {10},
  keywords = {Shortest paths, Approximation algorithms, Labeled paths, Wireless routing metrics}
}

@inproceedings{Azimov:2018:CPQ:3210259.3210264,
  author = {Azimov, Rustam and Grigorev, Semyon},
  title = {Context-free Path Querying by Matrix Multiplication},
  booktitle = {Proceedings of the 1st ACM SIGMOD Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES)  and Network Data Analytics (NDA)},
  series = {GRADES-NDA '18},
  year = {2018},
  isbn = {978-1-4503-5695-4},
  location = {Houston, Texas},
  pages = {5:1--5:10},
  articleno = {5},
  numpages = {10},
  url = {http://doi.acm.org/10.1145/3210259.3210264},
  doi = {10.1145/3210259.3210264},
  acmid = {3210264},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {GPGPU, context-free grammar, context-free path querying, graph databases, matrix multiplication, transitive closure},
}

@article{fan2018scaling,
  title={Scaling-Up In-Memory Datalog Processing: Observations and Techniques},
  author={Fan, Zhiwei and Zhu, Jianqiao and Zhang, Zuyu and Albarghouthi, Aws and Koutris, Paraschos and Patel, Jignesh},
  journal={arXiv preprint arXiv:1812.03975},
  year={2018}
}


@article{albrechtefficient,
  title={Efficient multiplication of dense matrices over GF (2)},
  author={Albrecht, MR and Bard, GV and Hart, W},
  journal={arXiv preprint arXiv:0811.1714},
  year={2008}
}


@article{hellingsPathQuerying,
  title={Querying for Paths in Graphs using Context-Free Path Queries},
  author={Hellings, Jelle},
  journal={arXiv preprint arXiv:1502.02242},
  year={2015}
}


@manual{M4RI,
  key          = "M4RI",
  author       = "Martin Albrecht and Gregory Bard",
  organization = "The M4RI~Team",
  title        = "{The M4RI Library}",
  year         = 2019,
  url          = {https://bitbucket.org/malb/m4ri},
}

@inproceedings{hellingsRelational,
  title={Conjunctive context-free path queries},
  author={Hellings, Jelle},
  booktitle={Proceedings of ICDT'14},
  pages={119--130},
  year={2014}
}


@Misc{scipy,
  author =    {Eric Jones and Travis Oliphant and Pearu Peterson and others},
  title =     {{SciPy}: Open source scientific tools for {Python}},
  year =      {2001--2019},
  url = "http://www.scipy.org/",
  note = {[Online; accessed 5.3.2019]}
}


@inproceedings{arlazarov1970economical,
  title={On economical construction of the transitive closure of an oriented graph},
  author={Arlazarov, Vladimir L'vovich and Dinitz, Yefim A and Kronrod, MA and Faradzhev, IgorAleksandrovich},
  booktitle={Doklady Akademii Nauk},
  volume={194},
  number={3},
  pages={487--488},
  year={1970},
  organization={Russian Academy of Sciences}
}
@inproceedings{RDF,
  author={Zhang, X. and Feng, Z. and Wang, X. and Rao, G. and Wu, W.},
  title={Context-free path queries on RDF graphs},
  booktitle={International Semantic Web Conference},
  pages={632--648},
  year={2016},
  organization={Springer}
}

@book{FndDB,
  author = {Abiteboul, Serge and Hull, Richard and Vianu, Victor},
  title = {Foundations of Databases: The Logical Level},
  year = {1995},
  isbn = {0201537710},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {USA},
  edition = {1st}
}


@inproceedings{Grigorev:2017:CPQ:3166094.3166104,
 author = {Grigorev, Semyon and Ragozina, Anastasiya},
 title = {Context-free Path Querying with Structural Representation of Result},
 booktitle = {Proceedings of the 13th Central \& Eastern European Software Engineering Conference in Russia},
 series = {CEE-SECR '17},
 year = {2017},
 isbn = {978-1-4503-6396-9},
 location = {St. Petersburg, Russia},
 pages = {10:1--10:7},
 articleno = {10},
 numpages = {7},
 url = {http://doi.acm.org/10.1145/3166094.3166104},
 doi = {10.1145/3166094.3166104},
 acmid = {3166104},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CFPQ, GLL, LL, context-free grammar, graph database, graph parsing, path query, top-down parsing},
}

@inproceedings{Verbitskaia:2018:PCC:3241653.3241655,
 author = {Verbitskaia, Ekaterina and Kirillov, Ilya and Nozkin, Ilya and Grigorev, Semyon},
 title = {Parser Combinators for Context-free Path Querying},
 booktitle = {Proceedings of the 9th ACM SIGPLAN International Symposium on Scala},
 series = {Scala 2018},
 year = {2018},
 isbn = {978-1-4503-5836-1},
 location = {St. Louis, MO, USA},
 pages = {13--23},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/3241653.3241655},
 doi = {10.1145/3241653.3241655},
 acmid = {3241655},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Context-Free Language Reachability, Context-Free Path Querying, GLL, Generalized LL, Graph Databases, Language-Constrained Path Problem, Neo4j, Parser Combinators, Scala},
}
@InProceedings{10.1007/978-3-319-91662-0_17,
  author="Santos, Fred C.
  and Costa, Umberto S.
  and Musicante, Martin A.",
  editor="Mikkonen, Tommi
  and Klamma, Ralf
  and Hern{\'a}ndez, Juan",
  title="A Bottom-Up Algorithm for Answering Context-Free Path Queries in Graph Databases",
  booktitle="Web Engineering",
  year="2018",
  publisher="Springer International Publishing",
  address="Cham",
  pages="225--233",
  abstract="Many computing applications require processing of data that are directly collected from the Internet. In this context, the use of the Resource Description Framework (RDF) has became a common feature. The query and analysis of RDF data is paramount to explore the full potential of the data available on the Web. Query languages for RDF graph databases rely on the use of regular expressions to identify paths over the data. Some interesting queries, such as same-generation queries, cannot be expressed by regular expressions. We are interested in extending the expressiveness of queries over graph databases by using paths defined by context-free grammars. We introduce a new query algorithm to process context-free path queries over graph databases. Our approach is inspired by the LR(1) parsing techniques. A prototype was implemented and experiments were conducted to validate and compare the results of our algorithm with those obtained by similar approaches.",
  isbn="978-3-319-91662-0"
}

@inproceedings{Medeiros:2018:EEC:3167132.3167265,
  author = {Medeiros, Ciro M. and Musicante, Martin A. and Costa, Umberto S.},
  title = {Efficient Evaluation of Context-free Path Queries for Graph Databases},
  booktitle = {Proceedings of the 33rd Annual ACM Symposium on Applied Computing},
  series = {SAC '18},
  year = {2018},
  isbn = {978-1-4503-5191-1},
  location = {Pau, France},
  pages = {1230--1237},
  numpages = {8},
  url = {http://doi.acm.org/10.1145/3167132.3167265},
  doi = {10.1145/3167132.3167265},
  acmid = {3167265},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {context-free grammars, context-free paths in graphs, graph databases, query languages, top-down parsing},
}

@inproceedings{Mishin:2019:ECP:3327964.3328503,
  author = {Mishin, Nikita and Sokolov, Iaroslav and Spirin, Egor and Kutuev, Vladimir and Nemchinov, Egor and Gorbatyuk, Sergey and Grigorev, Semyon},
  title = {Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication},
  booktitle = {Proceedings of the 2Nd Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
  series = {GRADES-NDA'19},
  year = {2019},
  isbn = {978-1-4503-6789-9},
  location = {Amsterdam, Netherlands},
  pages = {12:1--12:5},
  articleno = {12},
  numpages = {5},
  url = {http://doi.acm.org/10.1145/3327964.3328503},
  doi = {10.1145/3327964.3328503},
  acmid = {3328503},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {CUDA, Context-free path querying, GPGPU, boolean matrix, context-free grammar, graph databases, matrix multiplication, transitive closure},
}

@misc{yang2019graphblast,
  title={GraphBLAST: A High-Performance Linear Algebra-based Graph Framework on the GPU},
  author={Carl Yang and Aydin Buluc and John D. Owens},
  year={2019},
  eprint={1908.01407},
  archivePrefix={arXiv},
  primaryClass={cs.DC}
}

@INPROCEEDINGS{8778293,
  author={P. {Cailliau} and T. {Davis} and V. {Gadepally} and J. {Kepner} and R. {Lipman} and J. {Lovitz} and K. {Ouaknine}},
  booktitle={2019 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW)},
  title={RedisGraph GraphBLAS Enabled Graph Database},
  year={2019},
  publisher = {{IEEE}},
  volume={},
  number={},
  pages={285-286},
  keywords={graph theory;matrix algebra;NoSQL databases;optimisation;sparse matrices;Redis module;Redis Labs;graph database   functionality;Redis database;adjacency matrices;sparse matrices;highly optimized library;sparse matrix operations;RedisGraph GraphBLAS enabled graph database;Benchmark testing;Sparse matrices;Instruction sets;Time factors;Software algorithms;Distributed   databases;graph;database;sparce matrices;graphblas;cypher},
  doi={10.1109/IPDPSW.2019.00054},
  ISSN={},
  month={May},
}

@INPROCEEDINGS{7761646,
author={J. {Kepner} and P. {Aaltonen} and D. {Bader} and A. {Buluc} and F. {Franchetti} and J. {Gilbert} and D. {Hutchison} and M. {Kumar} and A. {Lumsdaine} and H. {Meyerhenke} and S. {McMillan} and C. {Yang} and J. D. {Owens} and M. {Zalewski} and T. {Mattson} and J. {Moreira}},
booktitle={2016 IEEE High Performance Extreme Computing Conference (HPEC)},
title={Mathematical foundations of the GraphBLAS},
year={2016},
volume={},
number={},
pages={1-9},
keywords={graph theory;mathematics computing;matrix algebra;programming environments;mathematical foundations;GraphBLAS standard;GraphBlas.org;matrix-based graph algorithms;matrix-based graph operations;programming environments;adjacency matrices;incidence matrices;matrix multiplication;matrix mathematics;Matrices;Sparse matrices;Finite element analysis;Standards;Additives},
doi={10.1109/HPEC.2016.7761646},
ISSN={},
month={Sep.},}

@article{Wang:2017:GGG:3131890.3108140,
 author = {Wang, Yangzihao and Pan, Yuechao and Davidson, Andrew and Wu, Yuduo and Yang, Carl and Wang, Leyuan and Osama, Muhammad and Yuan, Chenshan and Liu, Weitang and Riffel, Andy T. and Owens, John D.},
 title = {Gunrock: GPU Graph Analytics},
 journal = {ACM Trans. Parallel Comput.},
 issue_date = {October 2017},
 volume = {4},
 number = {1},
 month = aug,
 year = {2017},
 issn = {2329-4949},
 pages = {3:1--3:49},
 articleno = {3},
 numpages = {49},
 url = {http://doi.acm.org/10.1145/3108140},
 doi = {10.1145/3108140},
 acmid = {3108140},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {GPU, Graph processing, runtime framework},
}

@inproceedings{ward2008distributed,
 author = {Ward, Charles B. and Wiegand, Nathan M. and Bradford, Phillip G.},
 title = {A Distributed Context-Free Language Constrained Shortest Path Algorithm},
 booktitle = {Proceedings of the 2008 37th International Conference on Parallel Processing},
 series = {ICPP '08},
 year = {2008},
 isbn = {978-0-7695-3374-2},
 pages = {373--380},
 numpages = {8},
 url = {https://doi.org/10.1109/ICPP.2008.67},
 doi = {10.1109/ICPP.2008.67},
 acmid = {1442530},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {labeled graphs, labeled paths},
}

@inproceedings{bradford2016fast,
  title={Fast point-to-point Dyck constrained shortest paths on a DAG},
  author={Bradford, Phillip G and Choppella, Venkatesh},
  booktitle={2016 IEEE 7th Annual Ubiquitous Computing, Electronics \& Mobile Communication Conference (UEMCON)},
  pages={1--7},
  year={2016},
  organization={IEEE}
}


@article{10.1145/3322125,
author = {Davis, Timothy A.},
title = {Algorithm 1000: SuiteSparse:GraphBLAS: Graph Algorithms in the Language of Sparse Linear Algebra},
year = {2019},
issue_date = {December 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {4},
issn = {0098-3500},
url = {https://doi.org/10.1145/3322125},
doi = {10.1145/3322125},
journal = {ACM Trans. Math. Softw.},
month = dec,
articleno = {44},
numpages = {25},
keywords = {sparse matrices, GraphBLAS, Graph algorithms}
}

@article{Zheng:2008:DAA:1328897.1328464,
 author = {Zheng, Xin and Rugina, Radu},
 title = {Demand-driven Alias Analysis for C},
 journal = {SIGPLAN Not.},
 issue_date = {January 2008},
 volume = {43},
 number = {1},
 month = jan,
 year = {2008},
 issn = {0362-1340},
 pages = {197--208},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1328897.1328464},
 doi = {10.1145/1328897.1328464},
 acmid = {1328464},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CFL reachability, alias analysis, demand-driven analysis, memory disambiguation, pointer analysis},
}

@inproceedings{veduradabatch,
author = {Vedurada, Jyothi and Nandivada, V. Krishna},
title = {Batch Alias Analysis},
year = {2019},
isbn = {9781728125084},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/ASE.2019.00091},
doi = {10.1109/ASE.2019.00091},
booktitle = {Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering},
pages = {936--948},
numpages = {13},
location = {San Diego, California},
series = {ASE '19}
}

@inproceedings{LPAR-21:Cauliflower_Solver_Generator_for,
  author    = {Nicholas Hollingum and Bernhard Scholz},
  title     = {Cauliflower: a Solver Generator for Context-Free Language Reachability},
  booktitle = {LPAR-21. 21st International Conference on Logic for Programming, Artificial Intelligence and Reasoning},
  editor    = {Thomas Eiter and David Sands},
  series    = {EPiC Series in Computing},
  volume    = {46},
  pages     = {171--180},
  year      = {2017},
  publisher = {EasyChair},
  bibsource = {EasyChair, https://easychair.org},
  issn      = {2398-7340},
  url       = {https://easychair.org/publications/paper/bnVq},
  doi       = {10.29007/tbm7}}

  @ARTICLE{Albert_statisticalmechanics,
      author = {R\'eka Albert and Albert-l\'aszl\'o Barab\'asi},
      title = {Statistical mechanics of complex networks},
      journal = {Rev. Mod. Phys},
      year = {},
      pages = {2002}
  }

@article{GraphQueryWithEarley,
  title={Subgraph queries by context-free grammars},
  author={Sevon, Petteri and Eronen, Lauri},
  journal={Journal of Integrative Bioinformatics},
  volume={5},
  number={2},
  pages={100},
  year={2008}
}

@inproceedings{NsparsePaper,
author={Y. {Nagasaka} and A. {Nukada} and S. {Matsuoka}},
booktitle={2017 46th International Conference on Parallel Processing (ICPP)},
title={High-Performance and Memory-Saving Sparse General Matrix-Matrix Multiplication for NVIDIA Pascal GPU},
year={2017},
volume={},
number={},
pages={101-110},
keywords={graphics processing units;matrix multiplication;parallel processing;shared memory systems;software performance evaluation;storage management;sparse general matrix-matrix multiplication;SpGEMM;NVIDIA Pascal GPU;graphics processing unit;high performance computing;on-chip shared memory;hash table;performance evaluation;memory usage reduction;Sparse matrices;Graphics processing units;Memory management;Acceleration;Instruction sets;Kernel;Parallel processing;Sparse matrix;SpGEMM;GPU},
doi={10.1109/ICPP.2017.19},
ISSN={2332-5690},
month={Aug}
}

@MISC{Cusp,
  author = "Steven Dalton and Nathan Bell and Luke Olson and Michael Garland",
  title = "Cusp: Generic Parallel Algorithms for Sparse Matrix and Graph Computations",
  year = "2014",
  url = "http://cusplibrary.github.io/",
  note = "Version 0.5.0"
}

@inproceedings{GpuMergePathPaper,
  author = {Green, Oded and McColl, Robert and Bader, David A.},
  title = {GPU Merge Path: A GPU Merging Algorithm},
  year = {2012},
  isbn = {9781450313162},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2304576.2304621},
  doi = {10.1145/2304576.2304621},
  booktitle = {Proceedings of the 26th ACM International Conference on Supercomputing},
  pages = {331–340},
  numpages = {10},
  keywords = {graphics processors, parallel systems, parallel algorithms, measurement of multiple-processor systems},
  location = {San Servolo Island, Venice, Italy},
  series = {ICS'12}
}


@INPROCEEDINGS{8731467, author={H. {Miao} and A. {Deshpande}}, booktitle={2019 IEEE 35th International Conference on Data Engineering (ICDE)}, title={Understanding Data Science Lifecycle Provenance via Graph Segmentation and Summarization}, year={2019}, volume={}, number={}, pages={1710-1713},}

@book{automata:theory:10.5555/1177300,
  author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
  title = {Introduction to Automata Theory,  Languages, and Computation (3rd Edition)}, year = {2006}, 
  isbn = {0321462254}, 
  publisher = {Addison-Wesley Longman Publishing Co., Inc.}, 
  address = {USA} 
}

@inproceedings{cs6345,
 author    = {Kathrin Hanauer and
               Monika Henzinger and
               Christian Schulz},
  editor    = {Simone Faro and
               Domenico Cantone},
  title     = {Faster Fully Dynamic Transitive Closure in Practice},
  booktitle = {18th International Symposium on Experimental Algorithms, {SEA} 2020,
               June 16-18, 2020, Catania, Italy},
  series    = {LIPIcs},
  volume    = {160},
  pages     = {14:1--14:14},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2020},
  month = {June},
  url = {http://eprints.cs.univie.ac.at/6345/},
  doi       = {10.4230/LIPIcs.SEA.2020.14},
  timestamp = {Tue, 16 Jun 2020 17:17:57 +0200},
  biburl    = {https://dblp.org/rec/conf/wea/HanauerH020.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{10.1007/3-540-57273-2_72,
author="Subramanian, Sairam",
editor="Lengauer, Thomas",
title="A fully dynamic data structure for reachability in planar digraphs",
booktitle="Algorithms---ESA '93",
year="1993",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="372--383",
abstract="In this paper we investigate the problem of maintaining all-pairs reachability information in a planar digraph G as it undergoes changes. We give a fully dynamic O(n)-space data structure to support an arbitrary sequence of operations that consist of adding new edges (or nodes), deleting some existing edge, and querying to find out if a given node v is reachable in G by a directed path from another node u.",
isbn="978-3-540-48032-7"
}
@article{IBARAKI198395,
title = "On-line computation of transitive closures of graphs",
journal = "Information Processing Letters",
volume = "16",
number = "2",
pages = "95 - 97",
year = "1983",
issn = "0020-0190",
doi = "https://doi.org/10.1016/0020-0190(83)90033-9",
url = "http://www.sciencedirect.com/science/article/pii/0020019083900339",
author = "T. Ibaraki and N. Katoh",
keywords = "Transitive closure, directed graph, on-line algorithm"
}
@inproceedings{Chaudhuri2008SubcubicAF,
  title={Subcubic algorithms for recursive state machines},
  author={Swarat Chaudhuri},
  booktitle={POPL '08},
  year={2008}
}
@article{10.1145/3158118,
author = {Chatterjee, Krishnendu and Choudhary, Bhavya and Pavlogiannis, Andreas},
title = {Optimal Dyck Reachability for Data-Dependence and Alias Analysis},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158118},
doi = {10.1145/3158118},
journal = {Proc. ACM Program. Lang.},
month = dec,
articleno = {30},
numpages = {30},
keywords = {Data-dependence analysis, CFL reachability, Dyck reachability, treewidth, Bidirected graphs}
}
@misc{chistikov2021subcubic,
      title={Subcubic Certificates for CFL Reachability}, 
      author={Dmitry Chistikov and Rupak Majumdar and Philipp Schepper},
      year={2021},
      eprint={2102.13095},
      archivePrefix={arXiv},
      primaryClass={cs.FL}
}
@inproceedings{Pacaci2020RegularPQ,
author = {Pacaci, Anil and Bonifati, Angela and \"{O}zsu, M. Tamer},
title = {Regular Path Query Evaluation on Streaming Graphs},
year = {2020},
isbn = {9781450367356},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3318464.3389733},
doi = {10.1145/3318464.3389733},
abstract = {We study persistent query evaluation over streaming graphs, which is becoming increasingly important. We focus on navigational queries that determine if there exists a path between two entities that satisfies a user-specified constraint. We adopt the Regular Path Query (RPQ) model that specifies navigational patterns with labeled constraints. We propose deterministic algorithms to efficiently evaluate persistent RPQs under both arbitrary and simple path semantics in a uniform manner. Experimental analysis on real and synthetic streaming graphs shows that the proposed algorithms can process up to tens of thousands of edges per second and efficiently answer RPQs that are commonly used in real-world workloads.},
booktitle = {Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data},
pages = {1415--1430},
numpages = {16},
keywords = {persistent query evaluation, streaming graphs, regular path queries},
location = {Portland, OR, USA},
series = {SIGMOD '20}
}
}


@InProceedings{rsm:analysis:10.1007/3-540-44585-4_18,
 author="Alur, Rajeev and Etessami, Kousha and Yannakakis, Mihalis",
 editor="Berry, G{\'e}rard and Comon, Hubert and Finkel, Alain",
 title="Analysis of Recursive State Machines",
 booktitle="Computer Aided Verification",
 year="2001",
 publisher="Springer Berlin Heidelberg",
 address="Berlin, Heidelberg",
 pages="207--220",
 abstract="Recursive state machines (RSMs) enhance the power of ordinary state machines by allowing vertices to correspond 
 either to ordinary states or to potentially recursive invocations of other state machines. RSMs can model the control 
 flow in sequential imperative programs containing recursive procedure calls. They can be viewed as a visual notation 
 extending Statecharts-like hierarchical state machines, where concurrency is disallowed but recursion is allowed. 
 They are also related to various models of pushdown systems studied in the verification and program analysis communities.",
 isbn="978-3-540-44585-2"
}


@INPROCEEDINGS{8249039,
author={P. G. {Bradford}},
booktitle={2017 IEEE 8th Annual Ubiquitous Computing, Electronics and Mobile Communication Conference (UEMCON)},
title={Efficient exact paths for dyck and semi-dyck labeled path reachability (extended abstract)},
year={2017},
volume={},
number={},
pages={247--253},
publisher = {{IEEE}},
keywords={computational complexity;directed graphs;formal languages;graph theory;matrix multiplication;reachability analysis;efficient exact paths;weighted digraph;exact path length problem;exact path problem;original edge weights;path solutions;labeled digraph;semiDyck languages;Dyck languages;labeled path problems;Grammar;Heuristic algorithms;Jacobian matrices;Costing;Algorithm design and analysis;Shortest path problem},
doi={10.1109/UEMCON.2017.8249039},
ISSN={},
month={Oct},}
@article{IMPAGLIAZZO2001367,
title = {On the Complexity of k-SAT},
journal = {Journal of Computer and System Sciences},
volume = {62},
number = {2},
pages = {367-375},
year = {2001},
issn = {0022-0000},
doi = {https://doi.org/10.1006/jcss.2000.1727},
url = {https://www.sciencedirect.com/science/article/pii/S0022000000917276},
author = {Russell Impagliazzo and Ramamohan Paturi},
}
@article{Gajentaan1995OnAC,
  title={On a class of O(n2) problems in computational geometry},
  author={Anka Gajentaan and M. Overmars},
  journal={Comput. Geom.},
  year={1995},
  volume={45},
  pages={140-152}
}
@inproceedings{Patrascu,
author = {Patrascu, Mihai},
title = {Towards Polynomial Lower Bounds for Dynamic Problems},
year = {2010},
isbn = {9781450300506},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1806689.1806772},
doi = {10.1145/1806689.1806772},
abstract = {We consider a number of dynamic problems with no known poly-logarithmic upper bounds, and show that they require nΩ(1) time per operation, unless 3SUM has strongly subquadratic algorithms. Our result is modular: (1) We describe a carefully-chosen dynamic version of set disjointness (the "multiphase problem"), and conjecture that it requires n^Omega(1) time per operation. All our lower bounds follow by easy reduction. (2) We reduce 3SUM to the multiphase problem. Ours is the first nonalgebraic reduction from 3SUM, and allows 3SUM-hardness results for combinatorial problems. For instance, it implies hardness of reporting all triangles in a graph. (3) It is plausible that an unconditional lower bound for the multiphase problem can be established via a number-on-forehead communication game.},
booktitle = {Proceedings of the Forty-Second ACM Symposium on Theory of Computing},
pages = {603–610},
numpages = {8},
keywords = {3SUM, dynamic data structures, lower bounds},
location = {Cambridge, Massachusetts, USA},
series = {STOC '10}
}

@article{barrett2000formal,
author = {Barrett, Chris and Jacob, Riko and Marathe, Madhav},
title = {Formal-Language-Constrained Path Problems},
year = {2000},
issue_date = {May 2000},
publisher = {Society for Industrial and Applied Mathematics},
address = {USA},
volume = {30},
number = {3},
issn = {0097-5397},
url = {https://doi.org/10.1137/S0097539798337716},
doi = {10.1137/S0097539798337716},
journal = {SIAM J. Comput.},
month = may,
pages = {809--837},
numpages = {29},
keywords = {World Wide Web, transportation planning, multicriteria problems, formal languages, algorithms, query processing, computational complexity, shortest paths}
}

@inproceedings{Yannakakis,
 author = {Yannakakis, Mihalis},
 title = {Graph-theoretic Methods in Database Theory},
 booktitle = {Proceedings of the Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
 series = {PODS '90},
 year = {1990},
 isbn = {0-89791-352-3},
 location = {Nashville, Tennessee, USA},
 pages = {230--242},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/298514.298576},
 doi = {10.1145/298514.298576},
 acmid = {298576},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{Kuijpers:2019:ESC:3335783.3335791,
 author = {Kuijpers, Jochem and Fletcher, George and Yakovets, Nikolay and Lindaaker, Tobias},
 title = {An Experimental Study of Context-Free Path Query Evaluation Methods},
 booktitle = {Proceedings of the 31st International Conference on Scientific and Statistical Database Management},
 series = {SSDBM '19},
 year = {2019},
 isbn = {978-1-4503-6216-0},
 location = {Santa Cruz, CA, USA},
 pages = {121--132},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/3335783.3335791},
 doi = {10.1145/3335783.3335791},
 acmid = {3335791},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@article{10.1145/1328897.1328460,
author = {Chaudhuri, Swarat},
title = {Subcubic Algorithms for Recursive State Machines},
year = {2008},
issue_date = {January 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1328897.1328460},
doi = {10.1145/1328897.1328460},
journal = {SIGPLAN Not.},
month = jan,
pages = {159–169},
numpages = {11},
keywords = {recursive state machines, interprocedural analysis, cubic bottleneck, transitive closure, CFL-reachability, context-free languages, pushdown systems}
}
  
@inproceedings{10.1145/1328438.1328460,
author = {Chaudhuri, Swarat},
title = {Subcubic Algorithms for Recursive State Machines},
year = {2008},
isbn = {9781595936899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1328438.1328460},
doi = {10.1145/1328438.1328460},
booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {159--169},
numpages = {11},
keywords = {pushdown systems, recursive state machines, transitive closure, CFL-reachability, context-free languages, cubic bottleneck, interprocedural analysis},
location = {San Francisco, California, USA},
series = {POPL '08}
}
  
@inproceedings{10.1145/2463664.2465216,
author = {Barcel\'{o} Baeza, Pablo},
title = {Querying Graph Databases},
year = {2013},
isbn = {9781450320665},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2463664.2465216},
doi = {10.1145/2463664.2465216},
booktitle = {Proceedings of the 32nd ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems},
pages = {175--188},
numpages = {14},
keywords = {containment, conjunctive regular path queries, graph databases, query evaluation, expressiveness},
location = {New York, New York, USA},
series = {PODS '13}
}

@inproceedings{10.1145/2960414.2960421,
author = {van Rest, Oskar and Hong, Sungpack and Kim, Jinha and Meng, Xuming and Chafi, Hassan},
title = {PGQL: A Property Graph Query Language},
year = {2016},
isbn = {9781450347808},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2960414.2960421},
doi = {10.1145/2960414.2960421},
booktitle = {Proceedings of the Fourth International Workshop on Graph Data Management Experiences and Systems},
articleno = {7},
numpages = {6},
keywords = {graph query languages, property graphs, graph-structured data},
location = {Redwood Shores, California},
series = {GRADES '16}
}

@InProceedings{10.1007/978-3-319-25007-6_1,
author="Kostylev, Egor V.
and Reutter, Juan L.
and Romero, Miguel
and Vrgo{\v{c}}, Domagoj",
editor="Arenas, Marcelo
and Corcho, Oscar
and Simperl, Elena
and Strohmaier, Markus
and d'Aquin, Mathieu
and Srinivas, Kavitha
and Groth, Paul
and Dumontier, Michel
and Heflin, Jeff
and Thirunarayan, Krishnaprasad
and Thirunarayan, Krishnaprasad
and Staab, Steffen",
title="SPARQL with Property Paths",
booktitle="The Semantic Web - ISWC 2015",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="3--18",
abstract="The original SPARQL proposal was often criticized for its inability to navigate through the structure of RDF documents. For this reason property paths were introduced in SPARQL 1.1, but up to date there are no theoretical studies examining how their addition to the language affects main computational tasks such as query evaluation, query containment, and query subsumption. In this paper we tackle all of these problems and show that although the addition of property paths has no impact on query evaluation, they do make the containment and subsumption problems substantially more difficult.",
isbn="978-3-319-25007-6"
}

@article{10.1145/3104031,
author = {Angles, Renzo and Arenas, Marcelo and Barcel\'{o}, Pablo and Hogan, Aidan and Reutter, Juan and Vrgo\v{c}, Domagoj},
title = {Foundations of Modern Query Languages for Graph Databases},
year = {2017},
issue_date = {November 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {5},
issn = {0360-0300},
url = {https://doi.org/10.1145/3104031},
doi = {10.1145/3104031},
journal = {ACM Comput. Surv.},
month = sep,
articleno = {68},
numpages = {40},
keywords = {navigation, query languages, Property graphs, aggregation, graph databases, graph patterns}
}

@article{10.1145/2850413,
author = {Libkin, Leonid and Martens, Wim and Vrgo\v{c}, Domagoj},
title = {Querying Graphs with Data},
year = {2016},
issue_date = {May 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {63},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/2850413},
doi = {10.1145/2850413},
journal = {J. ACM},
month = mar,
articleno = {14},
numpages = {53},
keywords = {Graph databases, XPath, data values, navigational queries}
}

@article{Wang2019,
  doi = {10.1007/s11280-019-00739-0},
  url = {https://doi.org/10.1007/s11280-019-00739-0},
  year = {2019},
  month = nov,
  publisher = {Springer Science and Business Media {LLC}},
  volume = {23},
  number = {3},
  pages = {1465--1496},
  author = {Wang, Xin and Wang, Simiao and Xin, Yueqi and Yang, Yajun and Li, Jianxin and Wang, Xiaofei},
  title = {Distributed Pregel-based provenance-aware regular path query processing on {RDF} knowledge graphs},
  journal = {World Wide Web}
}

@inproceedings{10.1145/2949689.2949711,
author = {Nol\'{e}, Maurizio and Sartiani, Carlo},
title = {Regular Path Queries on Massive Graphs},
year = {2016},
isbn = {9781450342155},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2949689.2949711},
doi = {10.1145/2949689.2949711},
booktitle = {Proceedings of the 28th International Conference on Scientific and Statistical Database Management},
articleno = {13},
numpages = {12},
location = {Budapest, Hungary},
series = {SSDBM '16}
}

@inproceedings{10.1145/3398682.3399163,
author = {Terekhov, Arseniy and Khoroshev, Artyom and Azimov, Rustam and Grigorev, Semyon},
title = {Context-Free Path Querying with Single-Path Semantics by Matrix Multiplication},
year = {2020},
isbn = {9781450380218},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3398682.3399163},
doi = {10.1145/3398682.3399163},
booktitle = {Proceedings of the 3rd Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
articleno = {5},
numpages = {12},
keywords = {matrix multiplication, transitive closure, Boolean matrix, CUDA, Context-free path querying, RedisGraph database, GPGPU, context-free grammar, linear algebra, graph databases},
location = {Portland, OR, USA},
series = {GRADES-NDA'20}
}

@inproceedings{10.5555/3291656.3291682,
author = {Li, Jiajia and Sun, Jimeng and Vuduc, Richard},
title = {HiCOO: Hierarchical Storage of Sparse Tensors},
year = {2018},
publisher = {IEEE Press},
booktitle = {Proceedings of the International Conference for High Performance Computing, Networking, Storage, and Analysis},
articleno = {19},
numpages = {15},
location = {Dallas, Texas},
series = {SC '18}
}

@article{10.14778/3384345.3384358,
author = {Gera, Prasun and Kim, Hyojong and Sao, Piyush and Kim, Hyesoon and Bader, David},
title = {Traversing Large Graphs on GPUs with Unified Memory},
year = {2020},
issue_date = {March 2020},
publisher = {VLDB Endowment},
volume = {13},
number = {7},
issn = {2150-8097},
url = {https://doi.org/10.14778/3384345.3384358},
doi = {10.14778/3384345.3384358},
journal = {Proc. VLDB Endow.},
month = mar,
pages = {1119--1133},
numpages = {15}
}

@INPROCEEDINGS{8946118,
  author    = {Steven Wei Der Chien and
               Ivy Bo Peng and
               Stefano Markidis},
  title     = {Performance Evaluation of Advanced Features in {CUDA} Unified Memory},
  booktitle = {2019 {IEEE/ACM} Workshop on Memory Centric High Performance Computing,
               MCHPC@SC 2019, Denver, CO, USA, November 18, 2019},
  pages     = {50--57},
  publisher = {{IEEE}},
  year      = {2019},
  url       = {https://doi.org/10.1109/MCHPC49590.2019.00014},
  doi       = {10.1109/MCHPC49590.2019.00014},
  timestamp = {Mon, 20 Jan 2020 19:48:47 +0100},
  biburl    = {https://dblp.org/rec/conf/sc/ChienPM19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.1007/978-3-662-54458-7_16,
author = {Bouyer, Patricia and Jug\'{e}, Vincent},
title = {Dynamic Complexity of the Dyck Reachability},
year = {2017},
isbn = {9783662544570},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-662-54458-7_16},
doi = {10.1007/978-3-662-54458-7_16},
booktitle = {Proceedings of the 20th International Conference on Foundations of Software Science and Computation Structures - Volume 10203},
pages = {265--280},
numpages = {16}
}

@misc{zhang2020conditional,
    title={Conditional Lower Bound for Inclusion-Based Points-to Analysis},
    author={Qirun Zhang},
    year={2020},
    eprint={2007.05569},
    archivePrefix={arXiv},
    primaryClass={cs.PL}
}
@article{pavlogiannis2020finegrained,
author = {Mathiasen, Anders Alnor and Pavlogiannis, Andreas},
title = {The Fine-Grained and Parallel Complexity of Andersen’s Pointer Analysis},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434315},
doi = {10.1145/3434315},
abstract = {Pointer analysis is one of the fundamental problems in static program analysis. Given a set of pointers, the task is to produce a useful over-approximation of the memory locations that each pointer may point-to at runtime. The most common formulation is Andersen’s Pointer Analysis (APA), defined as an inclusion-based set of m pointer constraints over a set of n pointers. Scalability is extremely important, as points-to information is a prerequisite to many other components in the static-analysis pipeline. Existing algorithms solve APA in O(n2· m) time, while it has been conjectured that the problem has no truly sub-cubic algorithm, with a proof so far having remained elusive. It is also well-known that APA can be solved in O(n2) time under certain sparsity conditions that hold naturally in some settings. Besides these simple bounds, the complexity of the problem has remained poorly understood. In this work we draw a rich fine-grained and parallel complexity landscape of APA, and present upper and lower bounds. First, we establish an O(n3) upper-bound for general APA, improving over O(n2· m) as n=O(m). Second, we show that even on-demand APA (“may a specific pointer a point to a specific location b?”) has an Ω(n3) (combinatorial) lower bound under standard complexity-theoretic hypotheses. This formally establishes the long-conjectured “cubic bottleneck” of APA, and shows that our O(n3)-time algorithm is optimal. Third, we show that under mild restrictions, APA is solvable in \~{O}(nω) time, where ω&lt;2.373 is the matrix-multiplication exponent. It is believed that ω=2+o(1), in which case this bound becomes quadratic. Fourth, we show that even under such restrictions, even the on-demand problem has an Ω(n2) lower bound under standard complexity-theoretic hypotheses, and hence our algorithm is optimal when ω=2+o(1). Fifth, we study the parallelizability of APA and establish lower and upper bounds: (i) in general, the problem is P-complete and hence unlikely parallelizable, whereas (ii) under mild restrictions, the problem is parallelizable. Our theoretical treatment formalizes several insights that can lead to practical improvements in the future.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {34},
numpages = {29},
keywords = {inclusion-based pointer analysis, fine-grained complexity, Dyck reachability, static pointer analysis}
}
@InProceedings{10.1007/978-3-319-41579-6_22,
author="Verbitskaia, Ekaterina
and Grigorev, Semyon
and Avdyukhin, Dmitry",
editor="Mazzara, Manuel
and Voronkov, Andrei",
title="Relaxed Parsing of Regular Approximations of String-Embedded Languages",
booktitle="Perspectives of System Informatics",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="291--302",
abstract="We present a technique for syntax analysis of a regular set of input strings. This problem is relevant for the analysis of string-embedded languages when a host program generates clauses of embedded language at run time. Our technique is based on a generalization of RNGLR algorithm, which, inherently, allows us to construct a finite representation of parse forest for regularly approximated set of input strings. This representation can be further utilized for semantic analysis and transformations in the context of reengineering, code maintenance, program understanding etc. The approach in question implements relaxed parsing: non-recognized strings in approximation set are ignored with no error detection.",
isbn="978-3-319-41579-6"
}


@inproceedings{10.1145/3302424.3303962,
author = {Jamour, Fuad and Abdelaziz, Ibrahim and Chen, Yuanzhao and Kalnis, Panos},
title = {Matrix Algebra Framework for Portable, Scalable and Efficient Query Engines for RDF Graphs},
year = {2019},
isbn = {9781450362818},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3302424.3303962},
doi = {10.1145/3302424.3303962},
booktitle = {Proceedings of the Fourteenth EuroSys Conference 2019},
articleno = {27},
numpages = {15},
keywords = {Graph Query Engines, RDF, Matrix Algebra},
location = {Dresden, Germany},
series = {EuroSys '19}
}

@article{DBLP:journals/corr/MetzlerM15a,
  author    = {Saskia Metzler and
               Pauli Miettinen},
  title     = {On Defining {SPARQL} with Boolean Tensor Algebra},
  journal   = {CoRR},
  volume    = {abs/1503.00301},
  year      = {2015},
  url       = {http://arxiv.org/abs/1503.00301},
  archivePrefix = {arXiv},
  eprint    = {1503.00301},
  timestamp = {Mon, 13 Aug 2018 16:46:25 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/MetzlerM15a.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.1145/3299869.3319882,
author = {Wadhwa, Sarisht and Prasad, Anagh and Ranu, Sayan and Bagchi, Amitabha and Bedathur, Srikanta},
title = {Efficiently Answering Regular Simple Path Queries on Large Labeled Networks},
year = {2019},
isbn = {9781450356435},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3299869.3319882},
doi = {10.1145/3299869.3319882},
booktitle = {Proceedings of the 2019 International Conference on Management of Data},
pages = {1463--1480},
numpages = {18},
keywords = {reachability query, regular expression, regular path query, knowledge graphs, random walks},
location = {Amsterdam, Netherlands},
series = {SIGMOD '19}
}
  
@article{Glushkov1961,
  doi = {10.1070/rm1961v016n05abeh004112},
  url = {https://doi.org/10.1070/rm1961v016n05abeh004112},
  year = {1961},
  month = oct,
  publisher = {{IOP} Publishing},
  volume = {16},
  number = {5},
  pages = {1--53},
  author = {V M Glushkov},
  title = {{THE} {ABSTRACT} {THEORY} {OF} {AUTOMATA}},
  journal = {Russian Mathematical Surveys}
}

@article{10.1016/S0022-0000(75)80046-8,
author = {Valiant, Leslie G.},
title = {General Context-Free Recognition in Less than Cubic Time},
year = {1975},
issue_date = {April, 1975},
publisher = {Academic Press, Inc.},
address = {USA},
volume = {10},
number = {2},
issn = {0022-0000},
url = {https://doi.org/10.1016/S0022-0000(75)80046-8},
doi = {10.1016/S0022-0000(75)80046-8},
journal = {J. Comput. Syst. Sci.},
month = apr,
pages = {308--315},
numpages = {8}
}

@InProceedings{10.1007/978-3-642-31235-9_12,
author="Koschmieder, Andr{\'e}
and Leser, Ulf",
editor="Ailamaki, Anastasia
and Bowers, Shawn",
title="Regular Path Queries on Large Graphs",
booktitle="Scientific and Statistical Database Management",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="177--194",
abstract="The significance of regular path queries (RPQs) on graph-like data structures has grown steadily over the past decade. RPQs are, often in restricted forms, part of graph-oriented query languages such as XQuery/XPath and SPARQL, and have applications in areas such as semantic, social, and biomedical networks. However, existing systems for evaluating RPQs are restricted either in the type of the graph (e.g., only trees), the type of regular expressions (e.g., only single steps), and/or the size of the graphs they can handle. No method has yet been developed that would be capable of efficiently evaluating general RPQs on large graphs, i.e., with millions of nodes/edges.",
isbn="978-3-642-31235-9"
}

@article{10.1177/1094342011403516,
author = {Bulu\c{c}, Ayd\i{}n and Gilbert, John R},
title = {The Combinatorial BLAS: Design, Implementation, and Applications},
year = {2011},
issue_date = {November  2011},
publisher = {Sage Publications, Inc.},
address = {USA},
volume = {25},
number = {4},
issn = {1094-3420},
url = {https://doi.org/10.1177/1094342011403516},
doi = {10.1177/1094342011403516},
journal = {Int. J. High Perform. Comput. Appl.},
month = nov,
pages = {496--509},
numpages = {14},
keywords = {sparse matrices, combinatorial scientific computing, Betweenness centrality, parallel graph library, graph analysis, Markov clustering, software framework, mathematical software, combinatorial BLAS}
}
  
@article{sato_2017, 
title={A linear algebraic approach to datalog evaluation}, 
volume={17}, DOI={10.1017/S1471068417000023}, 
number={3}, 
journal={Theory and Practice of Logic Programming}, 
publisher={Cambridge University Press}, 
author={SATO, TAISUKE}, 
year={2017}, 
pages={244–265}
}

@inproceedings{10.1145/2463676.2467799,
author = {Shao, Bin and Wang, Haixun and Li, Yatao},
title = {Trinity: A Distributed Graph Engine on a Memory Cloud},
year = {2013},
isbn = {9781450320375},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2463676.2467799},
doi = {10.1145/2463676.2467799},
abstract = {Computations performed by graph algorithms are data driven, and require a high degree of random data access. Despite the great progresses made in disk technology, it still cannot provide the level of efficient random access required by graph computation. On the other hand, memory-based approaches usually do not scale due to the capacity limit of single machines. In this paper, we introduce Trinity, a general purpose graph engine over a distributed memory cloud. Through optimized memory management and network communication, Trinity supports fast graph exploration as well as efficient parallel computing. In particular, Trinity leverages graph access patterns in both online and offline computation to optimize memory and communication for best performance. These enable Trinity to support efficient online query processing and offline analytics on large graphs with just a few commodity machines. Furthermore, Trinity provides a high level specification language called TSL for users to declare data schema and communication protocols, which brings great ease-of-use for general purpose graph management and computing. Our experiments show Trinity's performance in both low latency graph queries as well as high throughput graph analytics on web-scale, billion-node graphs.},
booktitle = {Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data},
pages = {505--516},
numpages = {12},
keywords = {graph database, memory cloud, distributed system},
location = {New York, New York, USA},
series = {SIGMOD '13}
}

@article{10.1016/j.websem.2005.06.005,
author = {Guo, Yuanbo and Pan, Zhengxiang and Heflin, Jeff},
title = {LUBM: A Benchmark for OWL Knowledge Base Systems},
year = {2005},
issue_date = {October, 2005},
publisher = {Elsevier Science Publishers B. V.},
address = {NLD},
volume = {3},
number = {2--3},
issn = {1570-8268},
url = {https://doi.org/10.1016/j.websem.2005.06.005},
doi = {10.1016/j.websem.2005.06.005},
abstract = {We describe our method for benchmarking Semantic Web knowledge base systems with respect to use in large OWL applications. We present the Lehigh University Benchmark (LUBM) as an example of how to design such benchmarks. The LUBM features an ontology for the university domain, synthetic OWL data scalable to an arbitrary size, 14 extensional queries representing a variety of properties, and several performance metrics. The LUBM can be used to evaluate systems with different reasoning capabilities and storage mechanisms. We demonstrate this with an evaluation of two memory-based systems and two systems with persistent storage.},
journal = {Web Semant.},
month = oct,
pages = {158--182},
numpages = {25},
keywords = {Knowledge base system, Lehigh University Benchmark, Evaluation, Semantic Web}
}

@InProceedings{10.1007/978-3-030-54832-2_6,
author="Orachev, Egor
and Epelbaum, Ilya
and Azimov, Rustam
and Grigorev, Semyon",
editor="Darmont, J{\'e}r{\^o}me
and Novikov, Boris
and Wrembel, Robert",
title="Context-Free Path Querying by Kronecker Product",
booktitle="Advances in Databases and Information Systems",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="49--59",
abstract="Context-free path queries (CFPQ) extend the regular path queries (RPQ) by allowing context-free grammars to be used as constraints for paths. Algorithms for CFPQ are actively developed, but J. Kuijpers et al. have recently concluded, that existing algorithms are not performant enough to be used in real-world applications. Thus the development of new algorithms for CFPQ is justified. In this paper, we provide a new CFPQ algorithm which is based on such linear algebra operations as Kronecker product and transitive closure and handles grammars presented as recursive state machines. Thus, the proposed algorithm can be implemented by using high-performance libraries and modern parallel hardware. Moreover, it avoids grammar growth which provides the possibility for queries optimization.",
isbn="978-3-030-54832-2"
}
@article{10.1145/258994.259006,
author = {Melski, David and Reps, Thomas},
title = {Interconvertbility of Set Constraints and Context-Free Language Reachability},
year = {1997},
issue_date = {Dec. 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/258994.259006},
doi = {10.1145/258994.259006},
abstract = {We show the interconvertibility of context-free-language reachability problems and a class of set-constraint problems: given a context-free-language reachability problem, we show how to construct a set-constraint problem whose answer gives a solution to the reachability problem; given a set-constraint problem, we show how to construct a context-free-language reachability problem whose answer gives a solution to the set-constraint problem. The interconvertibility of these two formalisms offers an conceptual advantage akin to the advantage gained from the interconvertibility of finite-state automata and regular expressions in formal language theory, namely, a problem can be formulated in whichever formalism is most natural. It also offers some insight into the "O(n3) bottleneck" for different types of program-analysis problems, and allows results previously obtained for context-free-language reachability problems to be applied to set-constraint problems.},
journal = {SIGPLAN Not.},
month = dec,
pages = {74–89},
numpages = {16}
}
@inproceedings{10.5555/271338.271343,
author = {Reps, Thomas},
title = {Program Analysis via Graph Reachability},
year = {1997},
isbn = {0262631806},
publisher = {MIT Press},
address = {Cambridge, MA, USA},
booktitle = {Proceedings of the 1997 International Symposium on Logic Programming},
pages = {5–19},
numpages = {15},
location = {Port Washington, New York, USA},
series = {ILPS '97}
}
@inproceedings{10.5555/788019.788876,
author = {Heintze, Nevin and McAllester, David},
title = {On the Cubic Bottleneck in Subtyping and Flow Analysis},
year = {1997},
isbn = {0818679255},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {We prove that certain data-flow and control-flow problems are 2NPDA-complete. This means that these problems are in the class 2NPDA and that they are hard for that class. The fact that they are in 2NPDA demonstrates the richness of the class. The fact that they are hard for 2NPDA can be interpreted as evidence they can not be solved in sub-cubic time --- the cubic time decision procedure for an arbitrary 2NPDA problem has not been improved since its discovery in 1968.},
booktitle = {Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science},
pages = {342},
numpages = {1},
series = {LICS '97}
}
@inproceedings{10.1145/2746539.2746609,
author = {Henzinger, Monika and Krinninger, Sebastian and Nanongkai, Danupon and Saranurak, Thatchaphol},
title = {Unifying and Strengthening Hardness for Dynamic Problems via the Online Matrix-Vector Multiplication Conjecture},
year = {2015},
isbn = {9781450335362},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2746539.2746609},
doi = {10.1145/2746539.2746609},
abstract = {Consider the following Online Boolean Matrix-Vector Multiplication problem: We are given an n x n matrix M and will receive n column-vectors of size n, denoted by v1, ..., vn, one by one. After seeing each vector vi, we have to output the product Mvi before we can see the next vector. A naive algorithm can solve this problem using O(n3) time in total, and its running time can be slightly improved to O(n3/log2 n) [Williams SODA'07]. We show that a conjecture that there is no truly subcubic (O(n3-ε)) time algorithm for this problem can be used to exhibit the underlying polynomial time hardness shared by many dynamic problems. For a number of problems, such as subgraph connectivity, Pagh's problem, d-failure connectivity, decremental single-source shortest paths, and decremental transitive closure, this conjecture implies tight hardness results. Thus, proving or disproving this conjecture will be very interesting as it will either imply several tight unconditional lower bounds or break through a common barrier that blocks progress with these problems. This conjecture might also be considered as strong evidence against any further improvement for these problems since refuting it will imply a major breakthrough for combinatorial Boolean matrix multiplication and other long-standing problems if the term "combinatorial algorithms" is interpreted as "Strassen-like algorithms" [Ballard et al. SPAA'11].The conjecture also leads to hardness results for problems that were previously based on diverse problems and conjectures -- such as 3SUM, combinatorial Boolean matrix multiplication, triangle detection, and multiphase -- thus providing a uniform way to prove polynomial hardness results for dynamic algorithms; some of the new proofs are also simpler or even become trivial. The conjecture also leads to stronger and new, non-trivial, hardness results, e.g., for the fully-dynamic densest subgraph and diameter problems.},
booktitle = {Proceedings of the Forty-Seventh Annual ACM Symposium on Theory of Computing},
pages = {21–30},
numpages = {10},
keywords = {lower bounds, dynamic graph algorithms},
location = {Portland, Oregon, USA},
series = {STOC '15}
}
@INPROCEEDINGS{8948597,
author={J. {van den Brand} and D. {Nanongkai} and T. {Saranurak}},
booktitle={2019 IEEE 60th Annual Symposium on Foundations of Computer Science (FOCS)}, 
title={Dynamic Matrix Inverse: Improved Algorithms and Matching Conditional Lower Bounds}, 
year={2019},
volume={},
number={},
pages={456-480},
}
@InProceedings{HellSinglePath,
author="Hellings, Jelle",
editor="Qin, Lu
and Zhang, Wenjie
and Zhang, Ying
and Peng, You
and Kato, Hiroyuki
and Wang, Wei
and Xiao, Chuan",
title="Explaining Results of Path Queries on Graphs",
booktitle="Software Foundations for Data Interoperability and Large Scale Graph Data Analytics",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="84--98",
abstract="Many graph query languages use, at their core, path queries that yield node pairs that are connected by a path of interest. For the end-user, such node pairs only give limited insight as to why this query result is obtained, as the pair does not directly identify the underlying path of interest. To address this limitation of path queries, we propose the single-path semantics, which evaluates path queries to, for each node pair (m, n), a single path from m to n satisfying the conditions of the query. To put our proposal in practice, we provide an efficient algorithm for evaluating context-free path queries, a particular powerful type of path queries, using the single-path semantics. Additionally, we perform a short evaluation of our techniques that shows that the single-path semantics is practically feasible, even when query results grow large.",
isbn="978-3-030-61133-0"
}
@inproceedings{YanSCA,
author = {Yan, Dacong and Xu, Harry and Rountev, Atanas},
year = {2011},
month = {01},
pages = {155-165},
title = {Demand-driven context-sensitive alias analysis for Java},
journal = {2011 International Symposium on Software Testing and Analysis, ISSTA 2011 - Proceedings},
doi = {10.1145/2001420.2001440}
}
@article{10.1145/3428301,
author = {Sui, Yulei and Cheng, Xiao and Zhang, Guanqin and Wang, Haoyu},
title = {Flow2Vec: Value-Flow-Based Precise Code Embedding},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428301},
doi = {10.1145/3428301},
abstract = {Code embedding, as an emerging paradigm for source code analysis, has attracted much attention over the past few years. It aims to represent code semantics through distributed vector representations, which can be used to support a variety of program analysis tasks (e.g., code summarization and semantic labeling). However, existing code embedding approaches are intraprocedural, alias-unaware and ignoring the asymmetric transitivity of directed graphs abstracted from source code, thus they are still ineffective in preserving the structural information of code. This paper presents Flow2Vec, a new code embedding approach that precisely preserves interprocedural program dependence (a.k.a value-flows). By approximating the high-order proximity, i.e., the asymmetric transitivity of value-flows, Flow2Vec embeds control-flows and alias-aware data-flows of a program in a low-dimensional vector space. Our value-flow embedding is formulated as matrix multiplication to preserve context-sensitive transitivity through CFL reachability by filtering out infeasible value-flow paths. We have evaluated Flow2Vec using 32 popular open-source projects. Results from our experiments show that Flow2Vec successfully boosts the performance of two recent code embedding approaches codevec and codeseq for two client applications, i.e., code classification and code summarization. For code classification, Flow2Vec improves codevec with an average increase of 21.2%, 20.1% and 20.7% in precision, recall and F1, respectively. For code summarization, Flow2Vec outperforms codeseq by an average of 13.2%, 18.8% and 16.0% in precision, recall and F1, respectively.},
journal = {Proc. ACM Program. Lang.},
month = nov,
articleno = {233},
numpages = {27},
keywords = {Flow2Vec, code embedding, asymmetric transitivity, value-flows}
}
@article{10.1145/3093336.3037744,
author = {Wang, Kai and Hussain, Aftab and Zuo, Zhiqiang and Xu, Guoqing and Amiri Sani, Ardalan},
title = {Graspan: A Single-Machine Disk-Based Graph System for Interprocedural Static Analyses of Large-Scale Systems Code},
year = {2017},
issue_date = {April 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {4},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093336.3037744},
doi = {10.1145/3093336.3037744},
abstract = {There is more than a decade-long history of using static analysis to find bugs in systems such as Linux. Most of the existing static analyses developed for these systems are simple checkers that find bugs based on pattern matching. Despite the presence of many sophisticated interprocedural analyses, few of them have been employed to improve checkers for systems code due to their complex implementations and poor scalability. In this paper, we revisit the scalability problem of interprocedural static analysis from a "Big Data" perspective. That is, we turn sophisticated code analysis into Big Data analytics and leverage novel data processing techniques to solve this traditional programming language problem. We develop Graspan, a disk-based parallel graph system that uses an edge-pair centric computation model to compute dynamic transitive closures on very large program graphs.We implement context-sensitive pointer/alias and dataflow analyses on Graspan. An evaluation of these analyses on large codebases such as Linux shows that their Graspan implementations scale to millions of lines of code and are much simpler than their original implementations. Moreover, we show that these analyses can be used to augment the existing checkers; these augmented checkers uncovered 132 new NULL pointer bugs and 1308 unnecessary NULL tests in Linux 4.4.0-rc5, PostgreSQL 8.3.9, and Apache httpd 2.2.18.},
journal = {SIGPLAN Not.},
month = apr,
pages = {389--404},
numpages = {16},
keywords = {disk-based systems, static analysis, graph processing}
}
@inbook{databasebook,
author = {Abiteboul, Serge and Hull, Richard and Vianu, Victor},
year = {1995},
month = {01},
pages = {},
title = {Foundations of Databases},
isbn = {0-201-53771-0}
}
@article{10.1145/1103845.1094817,
author = {Sridharan, Manu and Gopan, Denis and Shan, Lexin and Bod\'{\i}k, Rastislav},
title = {Demand-Driven Points-to Analysis for Java},
year = {2005},
issue_date = {October 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1103845.1094817},
doi = {10.1145/1103845.1094817},
abstract = {We present a points-to analysis technique suitable for environments with small time and memory budgets, such as just-in-time (JIT) compilers and interactive development environments (IDEs). Our technique is demand-driven, performing only the work necessary to answer each query (a request for a variable's points-to information) issued by a client. In cases where even the demand-driven approach exceeds the time budget for a query, we employ early termination, i.e., stopping the analysis prematurely and returning an over-approximated result to the client. Our technique improves on previous demand-driven points-to analysis algorithms [17, 33] by achieving much higher precision under small time budgets and early termination.We formulate Andersen's analysis [5] for Java as a CFL-reachability problem [33]. This formulation shows that Andersen's analysis for Java is a balanced-parentheses problem, an insight that enables our new techniques. We exploit the balanced parentheses structure to approximate Andersen's analysis by regularizing the CFL-reachability problem, yielding an asymptotically cheaper algorithm. We also show how to regain most of the precision lost in the regular approximation as needed through refinement. Our evaluation shows that our regularization and refinement approach achieves nearly the precision of field-sensitive Andersen's analysis in time budgets as small as 2ms per query. Our technique can yield speedups of up to 16x over computing an exhaustive Andersen's analysis for some clients, with little to no precision loss.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {59–76},
numpages = {18},
keywords = {refinement, context-free language reachability, points-to analysis, demand-driven analysis}
}
@INPROCEEDINGS{7516027,
author={Anderson, Michael J. and Sundaram, Narayanan and Satish, Nadathur and Patwary, Md. Mostofa Ali and Willke, Theodore L. and Dubey, Pradeep},
booktitle={2016 IEEE International Parallel and Distributed Processing Symposium (IPDPS)}, 
title={GraphPad: Optimized Graph Primitives for Parallel and Distributed Platforms}, 
year={2016},
volume={},
number={},
pages={313-322},
doi={10.1109/IPDPS.2016.86}}
@article{10.14778/2809974.2809983,
author = {Sundaram, Narayanan and Satish, Nadathur and Patwary, Md Mostofa Ali and Dulloor, Subramanya R. and Anderson, Michael J. and Vadlamudi, Satya Gautam and Das, Dipankar and Dubey, Pradeep},
title = {GraphMat: High Performance Graph Analytics Made Productive},
year = {2015},
issue_date = {July 2015},
publisher = {VLDB Endowment},
volume = {8},
number = {11},
issn = {2150-8097},
url = {https://doi.org/10.14778/2809974.2809983},
doi = {10.14778/2809974.2809983},
abstract = {Given the growing importance of large-scale graph analytics, there is a need to improve the performance of graph analysis frameworks without compromising on productivity. GraphMat is our solution to bridge this gap between a user-friendly graph analytics framework and native, hand-optimized code. GraphMat functions by taking vertex programs and mapping them to high performance sparse matrix operations in the backend. We thus get the productivity benefits of a vertex programming framework without sacrificing performance. GraphMat is a single-node multicore graph framework written in C++ which has enabled us to write a diverse set of graph algorithms with the same effort compared to other vertex programming frameworks. GraphMat performs 1.1-7X faster than high performance frameworks such as GraphLab, CombBLAS and Galois. GraphMat also matches the performance of MapGraph, a GPU-based graph framework, despite running on a CPU platform with significantly lower compute and bandwidth resources. It achieves better multicore scalability (13-15X on 24 cores) than other frameworks and is 1.2X off native, hand-optimized code on a variety of graph algorithms. Since GraphMat performance depends mainly on a few scalable and well-understood sparse matrix operations, GraphMat can naturally benefit from the trend of increasing parallelism in future hardware.},
journal = {Proc. VLDB Endow.},
month = {jul},
pages = {1214–1225},
numpages = {12}
}
@article{10.1145/3016078.2851145,
author = {Wang, Yangzihao and Davidson, Andrew and Pan, Yuechao and Wu, Yuduo and Riffel, Andy and Owens, John D.},
title = {Gunrock: A High-Performance Graph Processing Library on the GPU},
year = {2016},
issue_date = {August 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {8},
issn = {0362-1340},
url = {https://doi.org/10.1145/3016078.2851145},
doi = {10.1145/3016078.2851145},
abstract = {For large-scale graph analytics on the GPU, the irregularity of data access/control flow and the complexity of programming GPUs have been two significant challenges for developing a programmable high-performance graph library. "Gunrock," our high-level bulk-synchronous graph-processing system targeting the GPU, takes a new approach to abstracting GPU graph analytics: rather than designing an abstraction around computation, Gunrock instead implements a novel data-centric abstraction centered on operations on a vertex or edge frontier. Gunrock achieves a balance between performance and expressiveness by coupling high-performance GPU computing primitives and optimization strategies with a high-level programming model that allows programmers to quickly develop new graph primitives with small code size and minimal GPU programming knowledge. We evaluate Gunrock on five graph primitives (BFS, BC, SSSP, CC, and PageRank) and show that Gunrock has on average at least an order of magnitude speedup over Boost and PowerGraph, comparable performance to the fastest GPU hardwired primitives, and better performance than any other GPU high-level graph library.},
journal = {SIGPLAN Not.},
month = {feb},
articleno = {11},
numpages = {12}
}
@inproceedings{10.1145/2621934.2621936,
author = {Fu, Zhisong and Personick, Michael and Thompson, Bryan},
title = {MapGraph: A High Level API for Fast Development of High Performance Graph Analytics on GPUs},
year = {2014},
isbn = {9781450329828},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2621934.2621936},
doi = {10.1145/2621934.2621936},
abstract = {High performance graph analytics are critical for a long list of application domains. In recent years, the rapid advancement of many-core processors, in particular graphical processing units (GPUs), has sparked a broad interest in developing high performance parallel graph programs on these architectures. However, the SIMT architecture used in GPUs places particular constraints on both the design and implementation of the algorithms and data structures, making the development of such programs difficult and time-consuming.We present MapGraph, a high performance parallel graph programming framework that delivers up to 3 billion Traversed Edges Per Second (TEPS) on a GPU. MapGraph provides a high-level abstraction that makes it easy to write graph programs and obtain good parallel speedups on GPUs. To deliver high performance, MapGraph dynamically chooses among different scheduling strategies depending on the size of the frontier and the size of the adjacency lists for the vertices in the frontier. In addition, a Structure Of Arrays (SOA) pattern is used to ensure coalesced memory access. Our experiments show that, for many graph analytics algorithms, an implementation, with our abstraction, is up to two orders of magnitude faster than a parallel CPU implementation and is comparable to state-of-the-art, manually optimized GPU implementations. In addition, with our abstraction, new graph analytics can be developed with relatively little effort.},
booktitle = {Proceedings of Workshop on GRAph Data Management Experiences and Systems},
pages = {1–6},
numpages = {6},
keywords = {Graph analytics, high-level API, GPU},
location = {Snowbird, UT, USA},
series = {GRADES'14}
}
@article{Jia2017ADM,
  title={A Distributed Multi-GPU System for Fast Graph Processing},
  author={Zhihao Jia and Yongkee Kwon and Galen M. Shipman and Patrick S. McCormick and Mattan Erez and Alexander Aiken},
  journal={Proc. VLDB Endow.},
  year={2017},
  volume={11},
  pages={297-310}
}
@inproceedings{Khorasani2014CuShaVG,
  title={CuSha: vertex-centric graph processing on GPUs},
  author={Farzad Khorasani and Keval Vora and Rajiv Gupta and Laxmi N. Bhuyan},
  booktitle={HPDC '14},
  year={2014}
}
@article{10.14778/2212351.2212354,
author = {Low, Yucheng and Bickson, Danny and Gonzalez, Joseph and Guestrin, Carlos and Kyrola, Aapo and Hellerstein, Joseph M.},
title = {Distributed GraphLab: A Framework for Machine Learning and Data Mining in the Cloud},
year = {2012},
issue_date = {April 2012},
publisher = {VLDB Endowment},
volume = {5},
number = {8},
issn = {2150-8097},
url = {https://doi.org/10.14778/2212351.2212354},
doi = {10.14778/2212351.2212354},
abstract = {While high-level data parallel frameworks, like MapReduce, simplify the design and implementation of large-scale data processing systems, they do not naturally or efficiently support many important data mining and machine learning algorithms and can lead to inefficient learning systems. To help fill this critical void, we introduced the GraphLab abstraction which naturally expresses asynchronous, dynamic, graph-parallel computation while ensuring data consistency and achieving a high degree of parallel performance in the shared-memory setting. In this paper, we extend the GraphLab framework to the substantially more challenging distributed setting while preserving strong data consistency guarantees.We develop graph based extensions to pipelined locking and data versioning to reduce network congestion and mitigate the effect of network latency. We also introduce fault tolerance to the GraphLab abstraction using the classic Chandy-Lamport snapshot algorithm and demonstrate how it can be easily implemented by exploiting the GraphLab abstraction itself. Finally, we evaluate our distributed implementation of the GraphLab abstraction on a large Amazon EC2 deployment and show 1-2 orders of magnitude performance gains over Hadoop-based implementations.},
journal = {Proc. VLDB Endow.},
month = {apr},
pages = {716–727},
numpages = {12}
}
@inproceedings{Wang2013AsynchronousLG,
  title={Asynchronous Large-Scale Graph Processing Made Easy},
  author={Guozhang Wang and Wenlei Xie and Alan J. Demers and Johannes Gehrke},
  booktitle={CIDR},
  year={2013}
}
@inproceedings{10.1145/2442516.2442530,
author = {Shun, Julian and Blelloch, Guy E.},
title = {Ligra: A Lightweight Graph Processing Framework for Shared Memory},
year = {2013},
isbn = {9781450319225},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2442516.2442530},
doi = {10.1145/2442516.2442530},
abstract = {There has been significant recent interest in parallel frameworks for processing graphs due to their applicability in studying social networks, the Web graph, networks in biology, and unstructured meshes in scientific simulation. Due to the desire to process large graphs, these systems have emphasized the ability to run on distributed memory machines. Today, however, a single multicore server can support more than a terabyte of memory, which can fit graphs with tens or even hundreds of billions of edges. Furthermore, for graph algorithms, shared-memory multicores are generally significantly more efficient on a per core, per dollar, and per joule basis than distributed memory systems, and shared-memory algorithms tend to be simpler than their distributed counterparts.In this paper, we present a lightweight graph processing framework that is specific for shared-memory parallel/multicore machines, which makes graph traversal algorithms easy to write. The framework has two very simple routines, one for mapping over edges and one for mapping over vertices. Our routines can be applied to any subset of the vertices, which makes the framework useful for many graph traversal algorithms that operate on subsets of the vertices. Based on recent ideas used in a very fast algorithm for breadth-first search (BFS), our routines automatically adapt to the density of vertex sets. We implement several algorithms in this framework, including BFS, graph radii estimation, graph connectivity, betweenness centrality, PageRank and single-source shortest paths. Our algorithms expressed using this framework are very simple and concise, and perform almost as well as highly optimized code. Furthermore, they get good speedups on a 40-core machine and are significantly more efficient than previously reported results using graph frameworks on machines with many more cores.},
booktitle = {Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {135–146},
numpages = {12},
keywords = {shared memory, parallel programming, graph algorithms},
location = {Shenzhen, China},
series = {PPoPP '13}
}
@inproceedings{10.1145/2723372.2735369,
author = {Perez, Yonathan and Sosi\v{c}, Rok and Banerjee, Arijit and Puttagunta, Rohan and Raison, Martin and Shah, Pararth and Leskovec, Jure},
title = {Ringo: Interactive Graph Analytics on Big-Memory Machines},
year = {2015},
isbn = {9781450327589},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2723372.2735369},
doi = {10.1145/2723372.2735369},
abstract = {We present Ringo, a system for analysis of large graphs. Graphs provide a way to represent and analyze systems of interacting objects (people, proteins, webpages) with edges between the objects denoting interactions (friendships, physical interactions, links). Mining graphs provides valuable insights about individual objects as well as the relationships among them.In building Ringo, we take advantage of the fact that machines with large memory and many cores are widely available and also relatively affordable. This allows us to build an easy-to-use interactive high-performance graph analytics system. Graphs also need to be built from input data, which often resides in the form of relational tables. Thus, Ringo provides rich functionality for manipulating raw input data tables into various kinds of graphs. Furthermore, Ringo also provides over 200 graph analytics functions that can then be applied to constructed graphs.We show that a single big-memory machine provides a very attractive platform for performing analytics on all but the largest graphs as it offers excellent performance and ease of use as compared to alternative approaches. With Ringo, we also demonstrate how to integrate graph analytics with an iterative process of trial-and-error data exploration and rapid experimentation, common in data mining workloads.},
booktitle = {Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data},
pages = {1105–1110},
numpages = {6},
keywords = {graphs, graph analytics, graph processing, performance, algorithms, networks},
location = {Melbourne, Victoria, Australia},
series = {SIGMOD '15}
}
@article{10.1145/2858788.2688507,
author = {Zhang, Kaiyuan and Chen, Rong and Chen, Haibo},
title = {NUMA-Aware Graph-Structured Analytics},
year = {2015},
issue_date = {August 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {8},
issn = {0362-1340},
url = {https://doi.org/10.1145/2858788.2688507},
doi = {10.1145/2858788.2688507},
abstract = { Graph-structured analytics has been widely adopted in a number of big data applications such as social computation, web-search and recommendation systems. Though much prior research focuses on scaling graph-analytics on distributed environments, the strong desire on performance per core, dollar and joule has generated considerable interests of processing large-scale graphs on a single server-class machine, which may have several terabytes of RAM and 80 or more cores. However, prior graph-analytics systems are largely neutral to NUMA characteristics and thus have suboptimal performance. This paper presents a detailed study of NUMA characteristics and their impact on the efficiency of graph-analytics. Our study uncovers two insights: 1) either random or interleaved allocation of graph data will significantly hamper data locality and parallelism; 2) sequential inter-node (i.e., remote) memory accesses have much higher bandwidth than both intra- and inter-node random ones. Based on them, this paper describes Polymer, a NUMA-aware graph-analytics system on multicore with two key design decisions. First, Polymer differentially allocates and places topology data, application-defined data and mutable runtime states of a graph system according to their access patterns to minimize remote accesses. Second, for some remaining random accesses, Polymer carefully converts random remote accesses into sequential remote accesses, by using lightweight replication of vertices across NUMA nodes. To improve load balance and vertex convergence, Polymer is further built with a hierarchical barrier to boost parallelism and locality, an edge-oriented balanced partitioning for skewed graphs, and adaptive data structures according to the proportion of active vertices. A detailed evaluation on an 80-core machine shows that Polymer often outperforms the state-of-the-art single-machine graph-analytics systems, including Ligra, X-Stream and Galois, for a set of popular real-world and synthetic graphs. },
journal = {SIGPLAN Not.},
month = {jan},
pages = {183–193},
numpages = {11},
keywords = {Graph-structured Analytics, Non-uniform Memory Access (NUMA)}
}

@inproceedings{10.1145/2688500.2688507,
author = {Zhang, Kaiyuan and Chen, Rong and Chen, Haibo},
title = {NUMA-Aware Graph-Structured Analytics},
year = {2015},
isbn = {9781450332057},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2688500.2688507},
doi = {10.1145/2688500.2688507},
abstract = { Graph-structured analytics has been widely adopted in a number of big data applications such as social computation, web-search and recommendation systems. Though much prior research focuses on scaling graph-analytics on distributed environments, the strong desire on performance per core, dollar and joule has generated considerable interests of processing large-scale graphs on a single server-class machine, which may have several terabytes of RAM and 80 or more cores. However, prior graph-analytics systems are largely neutral to NUMA characteristics and thus have suboptimal performance. This paper presents a detailed study of NUMA characteristics and their impact on the efficiency of graph-analytics. Our study uncovers two insights: 1) either random or interleaved allocation of graph data will significantly hamper data locality and parallelism; 2) sequential inter-node (i.e., remote) memory accesses have much higher bandwidth than both intra- and inter-node random ones. Based on them, this paper describes Polymer, a NUMA-aware graph-analytics system on multicore with two key design decisions. First, Polymer differentially allocates and places topology data, application-defined data and mutable runtime states of a graph system according to their access patterns to minimize remote accesses. Second, for some remaining random accesses, Polymer carefully converts random remote accesses into sequential remote accesses, by using lightweight replication of vertices across NUMA nodes. To improve load balance and vertex convergence, Polymer is further built with a hierarchical barrier to boost parallelism and locality, an edge-oriented balanced partitioning for skewed graphs, and adaptive data structures according to the proportion of active vertices. A detailed evaluation on an 80-core machine shows that Polymer often outperforms the state-of-the-art single-machine graph-analytics systems, including Ligra, X-Stream and Galois, for a set of popular real-world and synthetic graphs. },
booktitle = {Proceedings of the 20th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {183–193},
numpages = {11},
keywords = {Graph-structured Analytics, Non-uniform Memory Access (NUMA)},
location = {San Francisco, CA, USA},
series = {PPoPP 2015}
}
@inproceedings{10.1145/3064176.3064191,
author = {Maass, Steffen and Min, Changwoo and Kashyap, Sanidhya and Kang, Woonhak and Kumar, Mohan and Kim, Taesoo},
title = {Mosaic: Processing a Trillion-Edge Graph on a Single Machine},
year = {2017},
isbn = {9781450349383},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3064176.3064191},
doi = {10.1145/3064176.3064191},
abstract = {Processing a one trillion-edge graph has recently been demonstrated by distributed graph engines running on clusters of tens to hundreds of nodes. In this paper, we employ a single heterogeneous machine with fast storage media (e.g., NVMe SSD) and massively parallel coprocessors (e.g., Xeon Phi) to reach similar dimensions. By fully exploiting the heterogeneous devices, we design a new graph processing engine, named Mosaic, for a single machine. We propose a new locality-optimizing, space-efficient graph representation---Hilbert-ordered tiles, and a hybrid execution model that enables vertex-centric operations in fast host processors and edge-centric operations in massively parallel coprocessors.Our evaluation shows that for smaller graphs, Mosaic consistently outperforms other state-of-the-art out-of-core engines by 3.2-58.6x and shows comparable performance to distributed graph engines. Furthermore, Mosaic can complete one iteration of the Pagerank algorithm on a trillion-edge graph in 21 minutes, outperforming a distributed disk-based engine by 9.2\texttimes{}.},
booktitle = {Proceedings of the Twelfth European Conference on Computer Systems},
pages = {527–543},
numpages = {17},
location = {Belgrade, Serbia},
series = {EuroSys '17}
}Pearce R, Gokhale M, Amato NM, 
@inproceedings{Gregor2005ThePB,
  title={The Parallel BGL : A Generic Library for Distributed Graph Computations},
  author={Douglas P. Gregor and Andrew Lumsdaine},
  year={2005}
}
@INPROCEEDINGS{6569865,  author={Pearce, Roger and Gokhale, Maya and Amato, Nancy M.},  booktitle={2013 IEEE 27th International Symposium on Parallel and Distributed Processing},   title={Scaling Techniques for Massive Scale-Free Graphs in Distributed (External) Memory},   year={2013},  volume={},  number={},  pages={825-836},  doi={10.1109/IPDPS.2013.72}}
@inproceedings{10.5555/1863103.1863113,
author = {Zaharia, Matei and Chowdhury, Mosharaf and Franklin, Michael J. and Shenker, Scott and Stoica, Ion},
title = {Spark: Cluster Computing with Working Sets},
year = {2010},
publisher = {USENIX Association},
address = {USA},
abstract = {MapReduce and its variants have been highly successful in implementing large-scale data-intensive applications on commodity clusters. However, most of these systems are built around an acyclic data flow model that is not suitable for other popular applications. This paper focuses on one such class of applications: those that reuse a working set of data across multiple parallel operations. This includes many iterative machine learning algorithms, as well as interactive data analysis tools. We propose a new framework called Spark that supports these applications while retaining the scalability and fault tolerance of MapReduce. To achieve these goals, Spark introduces an abstraction called resilient distributed datasets (RDDs). An RDD is a read-only collection of objects partitioned across a set of machines that can be rebuilt if a partition is lost. Spark can outperform Hadoop by 10x in iterative machine learning jobs, and can be used to interactively query a 39 GB dataset with sub-second response time.},
booktitle = {Proceedings of the 2nd USENIX Conference on Hot Topics in Cloud Computing},
pages = {10},
numpages = {1},
location = {Boston, MA},
series = {HotCloud'10}
} 
@inproceedings{10.1145/2517349.2522740,
author = {Roy, Amitabha and Mihailovic, Ivo and Zwaenepoel, Willy},
title = {X-Stream: Edge-Centric Graph Processing Using Streaming Partitions},
year = {2013},
isbn = {9781450323888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2517349.2522740},
doi = {10.1145/2517349.2522740},
abstract = {X-Stream is a system for processing both in-memory and out-of-core graphs on a single shared-memory machine. While retaining the scatter-gather programming model with state stored in the vertices, X-Stream is novel in (i) using an edge-centric rather than a vertex-centric implementation of this model, and (ii) streaming completely unordered edge lists rather than performing random access. This design is motivated by the fact that sequential bandwidth for all storage media (main memory, SSD, and magnetic disk) is substantially larger than random access bandwidth.We demonstrate that a large number of graph algorithms can be expressed using the edge-centric scatter-gather model. The resulting implementations scale well in terms of number of cores, in terms of number of I/O devices, and across different storage media. X-Stream competes favorably with existing systems for graph processing. Besides sequential access, we identify as one of the main contributors to better performance the fact that X-Stream does not need to sort edge lists during preprocessing.},
booktitle = {Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles},
pages = {472–488},
numpages = {17},
location = {Farminton, Pennsylvania},
series = {SOSP '13}
}
@inproceedings{10.1145/3087556.3087580,
author = {Dhulipala, Laxman and Blelloch, Guy and Shun, Julian},
title = {Julienne: A Framework for Parallel Graph Algorithms Using Work-Efficient Bucketing},
year = {2017},
isbn = {9781450345934},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3087556.3087580},
doi = {10.1145/3087556.3087580},
abstract = {Existing graph-processing frameworks let users develop efficient implementations for many graph problems, but none of them support efficiently bucketing vertices, which is needed for bucketing-based graph algorithms such as Delta-stepping and approximate set-cover. Motivated by the lack of simple, scalable, and efficient implementations of bucketing-based algorithms, we develop the Julienne framework, which extends a recent shared-memory graph processing framework called Ligra with an interface for maintaining a collection of buckets under vertex insertions and bucket deletions.We provide a theoretically efficient parallel implementation of our bucketing interface and study several bucketing-based algorithms that make use of it (either bucketing by remaining degree or by distance) to improve performance: the peeling algorithm for k-core (coreness), Delta-stepping, weighted breadth-first search, and approximate set cover. The implementations are all simple and concise (under 100 lines of code). Using our interface, we develop the first work-efficient parallel algorithm for k-core in the literature with nontrivial parallelism.We experimentally show that our bucketing implementation scales well and achieves high throughput on both synthetic and real-world workloads. Furthermore, the bucketing-based algorithms written in Julienne achieve up to 43x speedup on 72 cores with hyper-threading over well-tuned sequential baselines, significantly outperform existing work-inefficient implementations in Ligra, and either outperform or are competitive with existing special-purpose parallel codes for the same problem. We experimentally study our implementations on the largest publicly available graphs and show that they scale well in practice, processing real-world graphs with billions of edges in seconds, and hundreds of billions of edges in a few minutes. As far as we know, this is the first time that graphs at this scale have been analyzed in the main memory of a single multicore machine.},
booktitle = {Proceedings of the 29th ACM Symposium on Parallelism in Algorithms and Architectures},
pages = {293–304},
numpages = {12},
keywords = {experiments, shared memory, parallel programming, graph algorithms},
location = {Washington, DC, USA},
series = {SPAA '17}
}
@article{Yan2018GraphDDV,
  title={GraphD: Distributed Vertex-Centric Graph Processing Beyond the Memory Limit},
  author={Da Yan and Yuzhen Huang and Miao Liu and Hongzhi Chen and James Cheng and Huanhuan Wu and Chengcui Zhang},
  journal={IEEE Transactions on Parallel and Distributed Systems},
  year={2018},
  volume={29},
  pages={99-114}
}
@inproceedings{Sengupta2016GraphInAO,
  title={GraphIn: An Online High Performance Incremental Graph Processing Framework},
  author={Dipanjan Sengupta and Narayanan Sundaram and Xia Zhu and Theodore L. Willke and Jeffrey S. Young and Matthew Wolf and Karsten Schwan},
  booktitle={Euro-Par},
  year={2016}
}
@inproceedings{Andersen2005ProgramAA,
  title={Program Analysis and Specialization for the C Programming Language},
  author={Lars Ole Andersen and Peter Lee},
  year={2005}
}
@article{10.1145/222132.222146,
author = {Horwitz, Susan and Reps, Thomas and Sagiv, Mooly},
title = {Demand Interprocedural Dataflow Analysis},
year = {1995},
issue_date = {Oct. 1995},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {20},
number = {4},
issn = {0163-5948},
url = {https://doi.org/10.1145/222132.222146},
doi = {10.1145/222132.222146},
journal = {SIGSOFT Softw. Eng. Notes},
month = {oct},
pages = {104–115},
numpages = {12}
}

@inproceedings{10.1145/222124.222146,
author = {Horwitz, Susan and Reps, Thomas and Sagiv, Mooly},
title = {Demand Interprocedural Dataflow Analysis},
year = {1995},
isbn = {0897917162},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/222124.222146},
doi = {10.1145/222124.222146},
booktitle = {Proceedings of the 3rd ACM SIGSOFT Symposium on Foundations of Software Engineering},
pages = {104–115},
numpages = {12},
location = {Washington, D.C., USA},
series = {SIGSOFT '95}
}
@article{SAGIV1996131,
title = {Precise interprocedural dataflow analysis with applications to constant propagation},
journal = {Theoretical Computer Science},
volume = {167},
number = {1},
pages = {131-170},
year = {1996},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(96)00072-2},
url = {https://www.sciencedirect.com/science/article/pii/0304397596000722},
author = {Mooly Sagiv and Thomas Reps and Susan Horwitz},
abstract = {This paper concerns interprocedural dataflow-analysis problems in which the dataflow information at a program point is represented by an environment (i.e., a mapping from symbols to values), and the effect of a program operation is represented by a distributive environment transformer. We present two efficient algorithms that produce precise solutions: an exhaustive algorithm that finds values for all symbols at all program points, and a demand algorithm that finds the value for an individual symbol at a particular program point. Two interesting problems that can be handled by our algorithms are (decidable) variants of the interprocedural constant-propagation problem: copy-constant propagation and linear-constant propagation. The former interprets program statements of the form x ≔ 7 and x ≔ y. The latter also interprets statements of the form x ≔ 5 * y + 17. Experimental results on C programs have shown that•Although solving constant-propagation problems precisely (i.e., finding the meet-over-all-valid-paths solution, rather than the meet-over-all-paths solution) resulted in a slowdown by a factor ranging from 2.2 to 4.5, the precise algorithm found additional constants in 7 of 38 test programs.•In contrast to previous results for numeric Fortran programs, linear-constant propagation found more constants than copy-constant propagation in 6 of 38 test programs.•The demand algorithm, when used to demand values for all uses of scalar integer variables, was faster than the exhaustive algorithm by a factor ranging from 1.14 to about 6.}
}
@inproceedings{10.1145/2814270.2814307,
author = {Dietrich, Jens and Hollingum, Nicholas and Scholz, Bernhard},
title = {Giga-Scale Exhaustive Points-to Analysis for Java in under a Minute},
year = {2015},
isbn = {9781450336895},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2814270.2814307},
doi = {10.1145/2814270.2814307},
abstract = { Computing a precise points-to analysis for very large Java programs remains challenging despite the large body of research on points-to analysis. Any approach must solve an underlying dynamic graph reachability problem, for which the best algorithms have near-cubic worst-case runtime complexity, and, hence, previous work does not scale to programs with millions of lines of code. In this work, we present a novel approach for solving the field-sensitive points-to problem for Java with the means of (1) a transitive-closure data-structure, and (2) a pre-computed set of potentially matching load/store pairs to accelerate the fix-point calculation. Experimentation on Java benchmarks validates the superior performance of our approach over the standard context-free language reachability implementations. Our approach computes a points-to index for the OpenJDK with over 1.5 billion tuples in under a minute. },
booktitle = {Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {535–551},
numpages = {17},
keywords = {Transitive Closure, Context-free Language, Points-to Analysis, Java},
location = {Pittsburgh, PA, USA},
series = {OOPSLA 2015}
}
@inproceedings{10.1145/2491956.2462159,
author = {Zhang, Qirun and Lyu, Michael R. and Yuan, Hao and Su, Zhendong},
title = {Fast Algorithms for Dyck-CFL-Reachability with Applications to Alias Analysis},
year = {2013},
isbn = {9781450320146},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491956.2462159},
doi = {10.1145/2491956.2462159},
abstract = {The context-free language (CFL) reachability problem is a well-known fundamental formulation in program analysis. In practice, many program analyses, especially pointer analyses, adopt a restricted version of CFL-reachability, Dyck-CFL-reachability, and compute on edge-labeled bidirected graphs. Solving the all-pairs Dyck-CFL-reachability on such bidirected graphs is expensive. For a bidirected graph with n nodes and m edges, the traditional dynamic programming style algorithm exhibits a subcubic time complexity for the Dyck language with k kinds of parentheses. When the underlying graphs are restricted to bidirected trees, an algorithm with O(n log n log k) time complexity was proposed recently. This paper studies the Dyck-CFL-reachability problems on bidirected trees and graphs. In particular, it presents two fast algorithms with O(n) and O(n + m log m) time complexities on trees and graphs respectively. We have implemented and evaluated our algorithms on a state-of-the-art alias analysis for Java. Results on standard benchmarks show that our algorithms achieve orders of magnitude speedup and consume less memory.},
booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {435–446},
numpages = {12},
keywords = {dyck-cfl-reachability, alias analysis},
location = {Seattle, Washington, USA},
series = {PLDI '13}
}
@inproceedings{10.1145/2351676.2351720,
author = {Shang, Lei and Lu, Yi and Xue, Jingling},
title = {Fast and Precise Points-to Analysis with Incremental CFL-Reachability Summarisation: Preliminary Experience},
year = {2012},
isbn = {9781450312042},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2351676.2351720},
doi = {10.1145/2351676.2351720},
abstract = { We describe our preliminary experience in the design and implementation of a points-to analysis for Java, called EMU, that enables developers to perform pointer-related queries in programs undergoing constant changes in IDEs. EMU achieves fast response times by adopting a modular approach to incrementally updating method summaries upon small code changes: the points-to information in a method is summarised indirectly by CFL reachability rather than directly by points-to sets. Thus, the impact of a small code change made in a method is localised, requiring only its affected part to be re-summarised just to reflect the change. EMU achieves precision by being context-sensitive (for both method invocation and heap abstraction) and field-sensitive. Our evaluation shows that EMU can be promisingly deployed in IDEs where the changes are small. },
booktitle = {Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering},
pages = {270–273},
numpages = {4},
keywords = {Points-to analysis, Summarisation, CFL reachability},
location = {Essen, Germany},
series = {ASE 2012}
}
@inproceedings{10.1145/2647508.2647522,
author = {Milanova, Ana and Huang, Wei and Dong, Yao},
title = {CFL-Reachability and Context-Sensitive Integrity Types},
year = {2014},
isbn = {9781450329262},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2647508.2647522},
doi = {10.1145/2647508.2647522},
abstract = {Integrity types can help detect information flow vulnerabilities in web applications and Android apps. We study DFlow, a context-sensitive integrity type system and we give an interpretation of DFlow in terms of CFL-reachability. We propose DFlowCFL, a new, more precise integrity type system, and DFlowCFL-Infer, the corresponding type inference analysis, which is equivalent to CFL-reachability. DFlowCFL-Infer is an effective taint analysis for Android. It scales well and detects numerous privacy leaks in popular Android apps.},
booktitle = {Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools},
pages = {99–109},
numpages = {11},
keywords = {type system, inference, context-sensitivity, CFL-reachability},
location = {Cracow, Poland},
series = {PPPJ '14}
}
@inproceedings{10.1145/2660193.2660213,
author = {Zhang, Qirun and Xiao, Xiao and Zhang, Charles and Yuan, Hao and Su, Zhendong},
title = {Efficient Subcubic Alias Analysis for C},
year = {2014},
isbn = {9781450325851},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2660193.2660213},
doi = {10.1145/2660193.2660213},
abstract = {Inclusion-based alias analysis for C can be formulated as a context-free language (CFL) reachability problem. It is well known that the traditional cubic CFL-reachability algorithm does not scale well in practice. We present a highly scalable and efficient CFL-reachability-based alias analysis for C. The key novelty of our algorithm is to propagate reachability information along only original graph edges and bypass a large portion of summary edges, while the traditional CFL-reachability algorithm propagates along all summary edges. We also utilize the Four Russians' Trick - a key enabling technique in the subcubic CFL-reachability algorithm - in our alias analysis. We have implemented our subcubic alias analysis and conducted extensive experiments on widely-used C programs from the pointer analysis literature. The results demonstrate that our alias analysis scales extremely well in practice. In particular, it can analyze the recent Linux kernel (which consists of 10M SLOC) in about 30 seconds.},
booktitle = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages Applications},
pages = {829–845},
numpages = {17},
keywords = {cfl-reachability, alias analysis},
location = {Portland, Oregon, USA},
series = {OOPSLA '14}
}
@inproceedings{10.1145/360204.360208,
author = {Rehof, Jakob and F\"{a}hndrich, Manuel},
title = {Type-Base Flow Analysis: From Polymorphic Subtyping to CFL-Reachability},
year = {2001},
isbn = {1581133367},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/360204.360208},
doi = {10.1145/360204.360208},
abstract = {We present a novel approach to scalable implementation of type-based flow analysis with polymorphic subtyping. Using a new presentation of polymorphic subytping with instantiation constraints, we are able to apply context-free language (CFL) reachability techniques to type-based flow analysis. We develop a CFL-based algorithm for computing flow-information in time O(n³), where n is the size of the typed program. The algorithm substantially improves upon the best previously known algorithm for flow analysis based on polymorphic subtyping with complexity O(n8). Our technique also yields the first demand-driven algorithm for polymorphic subtype-based flow-computation. It works directly on higher-order programs with structured data of finite type (unbounded data structures are incorporated via finite approximations), supports context-sensitive, global flow summariztion and includes polymorphic recursion.},
booktitle = {Proceedings of the 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {54–66},
numpages = {13},
location = {London, United Kingdom},
series = {POPL '01}
}
@article{10.1145/3360574,
author = {Lu, Jingbo and Xue, Jingling},
title = {Precision-Preserving yet Fast Object-Sensitive Pointer Analysis with Partial Context Sensitivity},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360574},
doi = {10.1145/3360574},
abstract = {Object-sensitivity is widely used as a context abstraction for computing the points-to information context-sensitively for object-oriented languages like Java. Due to the combinatorial explosion of contexts in large programs, k-object-sensitive pointer analysis (under k-limiting), denoted k-obj, is scalable only for small values of k, where k⩽2 typically. A few recent solutions attempt to improve its efficiency by instructing k-obj to analyze only some methods in the program context-sensitively, determined heuristically by a pre-analysis. While already effective, these heuristics-based pre-analyses do not provide precision guarantees, and consequently, are limited in the efficiency gains achieved. We introduce a radically different approach, Eagle, that makes k-obj run significantly faster than the prior art while maintaining its precision. The novelty of Eagle is to enable k-obj to analyze a method with partial context-sensitivity, i.e., context-sensitively for only some of its selected variables/allocation sites. Eagle makes these selections during a lightweight pre-analysis by reasoning about context-free-language (CFL) reachability at the level of variables/objects in the program, based on a new CFL-reachability formulation of k-obj. We demonstrate the advances made by Eagle by comparing it with the prior art in terms of a set of popular Java benchmarks and applications.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {148},
numpages = {29},
keywords = {Pointer Analysis, Object Sensitivity, CFL Reachability}
}
@inproceedings{10.1007/978-3-642-37051-9_4,
author = {Lu, Yi and Shang, Lei and Xie, Xinwei and Xue, Jingling},
title = {An Incremental Points-to Analysis with CFL-Reachability},
year = {2013},
isbn = {9783642370502},
url = {https://doi.org/10.1007/978-3-642-37051-9_4},
doi = {10.1007/978-3-642-37051-9_4},
abstract = {Developing scalable and precise points-to analyses is increasingly important for analysing and optimising object-oriented programs where pointers are used pervasively. An incremental analysis for a program updates the existing analysis information after program changes to avoid reanalysing it from scratch. This can be efficiently deployed in software development environments where code changes are often small and frequent. This paper presents an incremental approach for demand-driven context-sensitive points-to analyses based on Context-Free Language (CFL) reachability. By tracing the CFL-reachable paths traversed in computing points-to sets, we can precisely identify and recompute on demand only the points-to sets affected by the program changes made. Combined with a flexible policy for controlling the granularity of traces, our analysis achieves significant speedups with little space overhead over reanalysis from scratch when evaluated with a null dereferencing client using 14 Java benchmarks.},
booktitle = {Proceedings of the 22nd International Conference on Compiler Construction},
pages = {61–81},
numpages = {21},
location = {Rome, Italy},
series = {CC'13}
}
@article{10.1145/195274.195287,
author = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly and Rosay, Genevieve},
title = {Speeding up Slicing},
year = {1994},
issue_date = {Dec. 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {19},
number = {5},
issn = {0163-5948},
url = {https://doi.org/10.1145/195274.195287},
doi = {10.1145/195274.195287},
abstract = {Program slicing is a fundamental operation for many software engineering tools. Currently, the most efficient algorithm for interprocedural slicing is one that uses a program representation called the system dependence graph. This paper defines a new algorithm for slicing with system dependence graphs that is asymptotically faster than the previous one. A preliminary experimental study indicates that the new algorithm is also significantly faster in practice, providing roughly a 6-fold speedup on examples of 348 to 757 lines.},
journal = {SIGSOFT Softw. Eng. Notes},
month = {dec},
pages = {11–20},
numpages = {10},
keywords = {program debugging, program dependence graph, flow-sensitive summary information, dynamic transitive closure, realizable path, dynamic programming, program slicing}
}

@inproceedings{10.1145/193173.195287,
author = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly and Rosay, Genevieve},
title = {Speeding up Slicing},
year = {1994},
isbn = {0897916913},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/193173.195287},
doi = {10.1145/193173.195287},
abstract = {Program slicing is a fundamental operation for many software engineering tools. Currently, the most efficient algorithm for interprocedural slicing is one that uses a program representation called the system dependence graph. This paper defines a new algorithm for slicing with system dependence graphs that is asymptotically faster than the previous one. A preliminary experimental study indicates that the new algorithm is also significantly faster in practice, providing roughly a 6-fold speedup on examples of 348 to 757 lines.},
booktitle = {Proceedings of the 2nd ACM SIGSOFT Symposium on Foundations of Software Engineering},
pages = {11–20},
numpages = {10},
keywords = {dynamic programming, program dependence graph, realizable path, program debugging, flow-sensitive summary information, dynamic transitive closure, program slicing},
location = {New Orleans, Louisiana, USA},
series = {SIGSOFT '94}
}
@inproceedings{10.1145/3037697.3037744,
author = {Wang, Kai and Hussain, Aftab and Zuo, Zhiqiang and Xu, Guoqing and Amiri Sani, Ardalan},
title = {Graspan: A Single-Machine Disk-Based Graph System for Interprocedural Static Analyses of Large-Scale Systems Code},
year = {2017},
isbn = {9781450344654},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3037697.3037744},
doi = {10.1145/3037697.3037744},
abstract = {There is more than a decade-long history of using static analysis to find bugs in systems such as Linux. Most of the existing static analyses developed for these systems are simple checkers that find bugs based on pattern matching. Despite the presence of many sophisticated interprocedural analyses, few of them have been employed to improve checkers for systems code due to their complex implementations and poor scalability. In this paper, we revisit the scalability problem of interprocedural static analysis from a "Big Data" perspective. That is, we turn sophisticated code analysis into Big Data analytics and leverage novel data processing techniques to solve this traditional programming language problem. We develop Graspan, a disk-based parallel graph system that uses an edge-pair centric computation model to compute dynamic transitive closures on very large program graphs.We implement context-sensitive pointer/alias and dataflow analyses on Graspan. An evaluation of these analyses on large codebases such as Linux shows that their Graspan implementations scale to millions of lines of code and are much simpler than their original implementations. Moreover, we show that these analyses can be used to augment the existing checkers; these augmented checkers uncovered 132 new NULL pointer bugs and 1308 unnecessary NULL tests in Linux 4.4.0-rc5, PostgreSQL 8.3.9, and Apache httpd 2.2.18.},
booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {389–404},
numpages = {16},
keywords = {static analysis, graph processing, disk-based systems},
location = {Xi'an, China},
series = {ASPLOS '17}
}
@INPROCEEDINGS{8820963,
  author={Zuo, Zhiqiang and Gu, Rong and Jiang, Xi and Wang, Zhaokang and Huang, Yihua and Wang, Linzhang and Li, Xuandong},
  booktitle={2019 IEEE International Parallel and Distributed Processing Symposium (IPDPS)}, 
  title={BigSpa: An Efficient Interprocedural Static Analysis Engine in the Cloud}, 
  year={2019},
  volume={},
  number={},
  pages={771-780},
  doi={10.1109/IPDPS.2019.00086}}
@InProceedings{10.1007/978-3-642-22110-1_36,
author="Hoder, Kry{\v{s}}tof
and Bj{\o}rner, Nikolaj
and de Moura, Leonardo",
editor="Gopalakrishnan, Ganesh
and Qadeer, Shaz",
title="$\mu$Z-- An Efficient Engine for Fixed Points with Constraints",
booktitle="Computer Aided Verification",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="457--462",
abstract="The $\mu$Z tool is a scalable, efficient engine for fixed points with constraints. It supports high-level declarative fixed point constraints over a combination of built-in and plugin domains. The built-in domains include formulas presented to the SMT solver Z3 and domains known from abstract interpretation. We present the interface to $\mu$Z, a number of the domains, and a set of examples illustrating the use of $\mu$Z.",
isbn="978-3-642-22110-1"
}
@InProceedings{10.1007/978-3-319-41540-6_23,
author="Jordan, Herbert
and Scholz, Bernhard
and Suboti{\'{c}}, Pavle",
editor="Chaudhuri, Swarat
and Farzan, Azadeh",
title="Souffl{\'e}: On Synthesis of Program Analyzers",
booktitle="Computer Aided Verification",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="422--430",
abstract="Souffl{\'e} is an open source programming framework that performs static program analysis expressed in Datalog on very large code bases, including points-to analysis on OpenJDK7 (1.4M program variables, 350K objects, 160K methods) in under a minute. Souffl{\'e} is being successfully used for Java security analyses at Oracle Labs due to (1) its high-performance, (2) support for rapid program analysis development, and (3) customizability. Souffl{\'e} incorporates the highly flexible Datalog-based program analysis paradigm while exhibiting performance results that are on-par with manually developed state-of-the-art tools. In this tool paper, we introduce the Souffl{\'e} architecture, usage and demonstrate its applicability for large-scale code analysis on the OpenJDK7 library as a use case.",
isbn="978-3-319-41540-6"
}
@inproceedings{10.1007/11575467_8,
author = {Whaley, John and Avots, Dzintars and Carbin, Michael and Lam, Monica S.},
title = {Using Datalog with Binary Decision Diagrams for Program Analysis},
year = {2005},
isbn = {3540297359},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/11575467_8},
doi = {10.1007/11575467_8},
abstract = {Many problems in program analysis can be expressed naturally and concisely in a declarative language like Datalog. This makes it easy to specify new analyses or extend or compose existing analyses. However, previous implementations of declarative languages perform poorly compared with traditional implementations. This paper describes bddbddb, a BDD-Based Deductive DataBase, which implements the declarative language Datalog with stratified negation, totally-ordered finite domains and comparison operators. bddbddb uses binary decision diagrams (BDDs) to efficiently represent large relations. BDD operations take time proportional to the size of the data structure, not the number of tuples in a relation, which leads to fast execution times. bddbddb is an effective tool for implementing a large class of program analyses. We show that a context-insensitive points-to analysis implemented with bddbddb is about twice as fast as a carefully hand-tuned version. The use of BDDs also allows us to solve heretofore unsolved problems, like context-sensitive pointer analysis for large programs.},
booktitle = {Proceedings of the Third Asian Conference on Programming Languages and Systems},
pages = {97–118},
numpages = {22},
location = {Tsukuba, Japan},
series = {APLAS'05}
}
@article{10.1145/1639949.1640108,
author = {Bravenboer, Martin and Smaragdakis, Yannis},
title = {Strictly Declarative Specification of Sophisticated Points-to Analyses},
year = {2009},
issue_date = {October 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1639949.1640108},
doi = {10.1145/1639949.1640108},
abstract = {We present the DOOP framework for points-to analysis of Java programs. DOOP builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. We carry the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively using a novel technique specifically targeting highly recursive Datalog programs.As a result, DOOP achieves several benefits, including full order-of-magnitude improvements in runtime. We compare DOOP with Lhotak and Hendren's PADDLE, which defines the state of the art for context-sensitive analyses. For the exact same logical points-to definitions (and, consequently, identical precision) DOOP is more than 15x faster than PADDLE for a 1-call-site sensitive analysis of the DaCapo benchmarks, with lower but still substantial speedups for other important analyses. Additionally, DOOP scales to very precise analyses that are impossible with PADDLE and Whaley et al.'s bddbddb, directly addressing open problems in past literature. Finally, our implementation is modular and can be easily configured to analyses with a wide range of characteristics, largely due to its declarativeness.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {243–262},
numpages = {20},
keywords = {datalog, declarative, DOOP, points-to analysis, bdds}
}

@inproceedings{10.1145/1640089.1640108,
author = {Bravenboer, Martin and Smaragdakis, Yannis},
title = {Strictly Declarative Specification of Sophisticated Points-to Analyses},
year = {2009},
isbn = {9781605587660},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1640089.1640108},
doi = {10.1145/1640089.1640108},
abstract = {We present the DOOP framework for points-to analysis of Java programs. DOOP builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. We carry the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively using a novel technique specifically targeting highly recursive Datalog programs.As a result, DOOP achieves several benefits, including full order-of-magnitude improvements in runtime. We compare DOOP with Lhotak and Hendren's PADDLE, which defines the state of the art for context-sensitive analyses. For the exact same logical points-to definitions (and, consequently, identical precision) DOOP is more than 15x faster than PADDLE for a 1-call-site sensitive analysis of the DaCapo benchmarks, with lower but still substantial speedups for other important analyses. Additionally, DOOP scales to very precise analyses that are impossible with PADDLE and Whaley et al.'s bddbddb, directly addressing open problems in past literature. Finally, our implementation is modular and can be easily configured to analyses with a wide range of characteristics, largely due to its declarativeness.},
booktitle = {Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications},
pages = {243–262},
numpages = {20},
keywords = {DOOP, points-to analysis, declarative, datalog, bdds},
location = {Orlando, Florida, USA},
series = {OOPSLA '09}
}
@inproceedings{10.1145/2723372.2742796,
author = {Aref, Molham and ten Cate, Balder and Green, Todd J. and Kimelfeld, Benny and Olteanu, Dan and Pasalic, Emir and Veldhuizen, Todd L. and Washburn, Geoffrey},
title = {Design and Implementation of the LogicBlox System},
year = {2015},
isbn = {9781450327589},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2723372.2742796},
doi = {10.1145/2723372.2742796},
abstract = {The LogicBlox system aims to reduce the complexity of software development for modern applications which enhance and automate decision-making and enable their users to evolve their capabilities via a ``self-service'' model. Our perspective in this area is informed by over twenty years of experience building dozens of mission-critical enterprise applications that are in use by hundreds of large enterprises across industries such as retail, telecommunications, banking, and government. We designed and built LogicBlox to be the system we wished we had when developing those applications.In this paper, we discuss the design considerations behind the LogicBlox system and give an overview of its implementation, highlighting innovative aspects. These include: LogiQL, a unified and declarative language based on Datalog; the use of purely functional data structures; novel join processing strategies; advanced incremental maintenance and live programming facilities; a novel concurrency control scheme; and built-in support for prescriptive and predictive analytics.},
booktitle = {Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data},
pages = {1371–1382},
numpages = {12},
keywords = {predictive analytics, logiql, logicblox, live programming, transaction repair, leapfrog triejoin, incremental maintenance, datalog},
location = {Melbourne, Victoria, Australia},
series = {SIGMOD '15}
}
@inproceedings{10.1145/3453483.3454085,
author = {Zuo, Zhiqiang and Zhang, Yiyu and Pan, Qiuhong and Lu, Shenming and Li, Yue and Wang, Linzhang and Li, Xuandong and Xu, Guoqing Harry},
title = {Chianina: An Evolving Graph System for Flow- and Context-Sensitive Analyses of Million Lines of C Code},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454085},
doi = {10.1145/3453483.3454085},
abstract = {Sophisticated static analysis techniques often have complicated implementations, much of which provides logic for tuning and scaling rather than basic analysis functionalities. This tight coupling of basic algorithms with special treatments for scalability makes an analysis implementation hard to (1) make correct, (2) understand/work with, and (3) reuse for other clients. This paper presents Chianina, a graph system we developed for fully context- and flow-sensitive analysis of large C programs. Chianina overcomes these challenges by allowing the developer to provide only the basic algorithm of an analysis and pushing the tuning/scaling work to the underlying system. Key to the success of Chianina is (1) an evolving graph formulation of flow sensitivity and (2) the leverage of out-of-core, disk support to deal with memory blowup resulting from context sensitivity. We implemented three context- and flow-sensitive analyses on top of Chianina and scaled them to large C programs like Linux (17M LoC) on a single commodity PC.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {914–929},
numpages = {16},
keywords = {static analysis, parallel computing, graph processing},
location = {Virtual, Canada},
series = {PLDI 2021}
}
@inproceedings{10.1145/3302424.3303972,
author = {Zuo, Zhiqiang and Thorpe, John and Wang, Yifei and Pan, Qiuhong and Lu, Shenming and Wang, Kai and Xu, Guoqing Harry and Wang, Linzhang and Li, Xuandong},
title = {Grapple: A Graph System for Static Finite-State Property Checking of Large-Scale Systems Code},
year = {2019},
isbn = {9781450362818},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3302424.3303972},
doi = {10.1145/3302424.3303972},
abstract = {Many real-world bugs in large-scale systems are related to object state that is supposed to obey a specified finite state machine (FSM). They are triggered when unexpected events occur on objects in certain states, making these objects transition in a way that violates their specifications. Detecting such FSM-related bugs with static analysis is challenging, especially in distributed systems that have large codebases.This paper presents a single-machine, disk-based graph system, called Grapple, which was designed to conduct precise and scalable checking of finite-state properties for very large codebases. Grapple detects bugs through context-sensitive, path-sensitive alias and dataflow analyses, which are both formulated as dynamic transitive-closure computations and automatically parallelized by the system. We propose a novel path constraint encoding/decoding algorithm to attach a path constraint to a graph edge, allowing the graph engine to efficiently recover a path and compute its constraint during the computation. We have implemented Grapple and conducted a comprehensive evaluation over widely deployed distributed systems. Grapple reported a total of 376 warnings, of which only 17 are false positives. Our results also demonstrate the scalability of Grapple: it took between 51 minutes and 33 hours to finish all the analyses on a low-end desktop with 16G memory and 1T SSD space, while the traditional approaches ran out of memory in all cases.},
booktitle = {Proceedings of the Fourteenth EuroSys Conference 2019},
articleno = {38},
numpages = {17},
keywords = {bug detection, graph processing, static analysis},
location = {Dresden, Germany},
series = {EuroSys '19}
}
@article{10.1145/3450492,
author = {Lu, Jingbo and He, Dongjie and Xue, Jingling},
title = {Eagle: CFL-Reachability-Based Precision-Preserving Acceleration of Object-Sensitive Pointer Analysis with Partial Context Sensitivity},
year = {2021},
issue_date = {July 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {30},
number = {4},
issn = {1049-331X},
url = {https://doi.org/10.1145/3450492},
doi = {10.1145/3450492},
abstract = {Object sensitivity is widely used as a context abstraction for computing the points-to information context-sensitively for object-oriented programming languages such as Java. Due to the combinatorial explosion of contexts in large object-oriented programs, k-object-sensitive pointer analysis (under k-limiting), denoted k-obj, is often inefficient even when it is scalable for small values of k, where k ⩽ 2 holds typically. A recent popular approach for accelerating k-obj trades precision for efficiency by instructing k-obj to analyze only some methods in a program context-sensitively, determined heuristically by a pre-analysis. In this article, we investigate how to develop a fundamentally different approach, Eagle, for designing a pre-analysis that can make k-obj run significantly faster while maintaining its precision. The novelty of Eagle is to enable k-obj to analyze a method with partial context sensitivity (i.e., context-sensitively for only some of its selected variables/allocation sites) by solving a context-free-language (CFL) reachability problem based on a new CFL-reachability formulation of k-obj. By regularizing one CFL for specifying field accesses and using another CFL for specifying method calls, we have formulated Eagle as a fully context-sensitive taint analysis (without k-limiting) that is both effective (by selecting the variables/allocation sites to be analyzed by k-obj context-insensitively so as to reduce the number of context-sensitive facts inferred by k-obj in the program) and efficient (by running linearly in terms of the number of pointer assignment edges in the program). As Eagle represents the first precision-preserving pre-analysis, our evaluation focuses on demonstrating its significant performance benefits in accelerating k-obj for a set of popular Java benchmarks and applications, with call graph construction, may-fail-casting, and polymorphic call detection as three important client analyses.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {jul},
articleno = {46},
numpages = {46},
keywords = {CFL-reachability, Pointer analysis, object sensitivity}
}
@inproceedings{pygraphblas,
  title={GraphBLAS Programmability: Python and MATLAB Interfaces},
  author={Timothy Mattson, Michel Pelletier, Timothy A Davis},
  year={2020},
series = {HPEC '20}
}

  
















  








