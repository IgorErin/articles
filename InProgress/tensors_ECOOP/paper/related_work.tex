\section{Related work}
\label{sec:related}
\subsection{CFL-reachability}
The CFL-reachability problem was introduced by Yannakakis~\cite{Yannakakis} to describe the Datalog chain query evaluation problem. Later, Reps et al.~\cite{10.1145/222124.222146, 10.5555/271338.271343, SAGIV1996131} proposed the CFL-reachability framework for interprocedural program analysis. Since then the CFL-reachability has been used to formulate a variety of static analyses, such as points-to and alias analysis~\cite{ 10.1145/3158118, 10.1145/2814270.2814307,  10.1145/3450492, 10.1145/3360574, 10.1007/978-3-642-37051-9_4, 10.1145/2351676.2351720, 10.1145/1103845.1094817, 10.1145/2491956.2462159, 10.1145/2660193.2660213, Zheng:2008:DAA:1328897.1328464}, data-dependence analysis~\cite{10.1145/3158118}, type inference analysis~\cite{10.1145/2647508.2647522}, type-base flow analysis~\cite{10.1145/360204.360208} and program slicing~\cite{10.1145/193173.195287}.

A cubic $O(n^3)$ algorithm for the CFL-reachability which uses dynamic programming technique, was proposed by Melski and Reps~\cite{10.1145/258994.259006}. This result was improved by a logarithmic factor by Chaudhuri~\cite{Chaudhuri2008SubcubicAF}, giving the worst-case runtime complexity $O(n^3/\log n)$. Unfortunately, no algorithm faster has been discovered, for general graphs with $n$ vertices and general context-free grammars, so the CFL-reachability is known to have a ``cubic bottleneck''~\cite{10.5555/788019.788876}. Recent result by Chatterjee et al.~\cite{10.1145/3158118} shows that the CFL-reachability in cubic time is optimal under combinatorial Boolean Matrix Multiplication (BMM) hypothesis. The cubic lower bound under the same hypothesis was also established for Andersen's Pointer Analysis directly~\cite{pavlogiannis2020finegrained}. The cubic runtime can be improved substantially in specific cases, by taking advantage of certain properties of the underlying graph (i.e. bidirected graphs)~\cite{10.1145/3158118, 10.1145/2491956.2462159} or grammar/context-free language (i.e. Dyck language of 1 parenthesis)~\cite{8249039, pavlogiannis2020finegrained}.

There are some algorithms in the context of database theory, where exists the equivalent problem called Context-Free Path Querying (CFPQ)~\cite{Azimov:2018:CPQ:3210259.3210264, Grigorev:2017:CPQ:3166094.3166104, hellingsPathQuerying, Medeiros:2018:EEC:3167132.3167265, 10.1007/978-3-030-54832-2_6, 10.1007/978-3-319-91662-0_17, 10.1145/3398682.3399163, 10.1007/978-3-319-41579-6_22}. It is important to mention that some of these algorithms reduce CFPQ evaluation to linear algebra operations: Azimov et al.~\cite{Azimov:2018:CPQ:3210259.3210264} reduce CFPQ to matrix multiplication and Orachev et al.~\cite{10.1007/978-3-030-54832-2_6} reduce CFPQ to Kronecker product. Additionally, recently Sato~\cite{sato_2017} proposed linear algebraic approach to Datalog evaluation. This approach is based on the transformation of Datalog program to a set of matrix equations, and can be used for Datalog chain queries evaluation which is equivalent to the CFL-reachability problem. Unfortunately, all three mentioned algorithms have worse than cubic $O(n^5)$ theoretical time complexity, whereas our algorithm has state-of-the-art theoretical time complexity, having all the advantages of linear algebra formulation at the same time.

\subsection{Graph processing systems}

State-of-the-art systems for large graph proccessing use different architectures including single‑machine and shared‑memory parallel ones~\cite{10.1145/3064176.3064191, 10.1145/2723372.2735369, 10.1145/2442516.2442530, Wang2013AsynchronousLG, 10.1145/2688500.2688507}, multi-core and multi-processor architectures \cite{10.1177/1094342011403516, Gregor2005ThePB, 6569865}, and distributed graph processing systems~\cite{ 10.1145/3087556.3087580, 10.1145/2621934.2621936, Jia2017ADM, Khorasani2014CuShaVG, 10.14778/2212351.2212354, 10.1145/2517349.2522740, Sengupta2016GraphInAO, 10.1145/3016078.2851145, Yan2018GraphDDV, 10.5555/1863103.1863113}. However, it is hard to use these engines for the implementation of the interprocedural program analysis tool without ground-up redesign~\cite{10.1145/3037697.3037744}.

There are many works which formulate specific graph algorithms in terms of linear algebra, for example, such algorithms as for computing transitive closure and all-pairs shortest paths.
Recently this direction was summarized in GraphBLAS API~\cite{7761646} which provides building blocks to develop a graph analysis algorithm in terms of linear algebra.
There is a number of implementations of this API, such as SuiteSparse:GraphBLAS~\cite{10.1145/3322125}, CombBLAS~\cite{10.1177/1094342011403516}, GraphBLAST~\cite{yang2019graphblast}, GraphMat~\cite{10.14778/2809974.2809983}, GraphPad~\cite{7516027}. 

We implemented our tool on top of SuiteSparse:GraphBLAS because it gives a very flexible and convenient way to construct graph algorithms by using primitive and highly-optimized building blocks based on the set of of sparse matrix operations.
\subsection{CFL-reachability-based code analysis tools}
Since CFL-reachability captures a certain sub-class of Datalog, Datalog can be employed as a domain specific language to express custom program analyses, reducing the complexity of developing program analyzers. Such Datalog-powered tools, which are able to run sophisticated static analysis include bddbddb~\cite{10.1007/11575467_8}, DOOP~\cite{10.1145/1640089.1640108}, LogicBlox~\cite{10.1145/2723372.2742796}, $\mu$Z~\cite{10.1007/978-3-642-22110-1_36}, Souffl{\'e}~\cite{10.1007/978-3-319-41540-6_23}. However, such engines are known to be fundamentally limited by the size of main memory and, therefore, are not able to scale well on a large code systems~\cite{10.1145/3453483.3454085}, and experience reduced performance compared to manually implemented tools~\cite{10.1007/978-3-319-41540-6_23}.

A single-machine, disk-based graph systems Grapple~\cite{10.1145/3302424.3303972}, Graspan~\cite{10.1145/3037697.3037744} and Chianina~\cite{10.1145/3453483.3454085} turn code analysis into bigdata analytics. The main goal of Graspan is to scale context-free CFL-reachability based analyses to large programs with disk support. A piece of work Chianina~\cite{10.1145/3453483.3454085} supports easy development of any context- and flow-sensitive analysis for C. Unfortunately, massive expensive disk I/Os remain the major performance bottleneck of disk-based graph processing.

