\section{Background}
\label{sec:background}
\subsection{CFL-reachability}
Let  $G =\langle\Sigma, N, S, P\rangle$ be a context-free grammar, where $\Sigma$ is a finite set of terminals (or terminal alphabet), $N$ is a finite set of nonterminals (or nonterminal alphabet), $S \in N$ is a start nonterminal, $P$ is a finite set of productions (grammar rules) of form $N_i \to \alpha$ where  $N_i \in N$, $\alpha \in (\Sigma \cup N)^*$.

Let $\mathcal{G} =  \langle V, E, \Sigma \rangle$ be a directed graph with edges labeled by elements of $\Sigma$.  The notation $(a, i, j)$ denotes an edge in $\mathcal{G}$ from node $i$ to node $j$ labeled with symbol $a$.  Each path in $\mathcal{G}$ defines a word over $\Sigma$ by concatenating, in order, the labels of the edges in the path. A path in $\mathcal{G}$ is an $S$-path if its word is in the language generated by context-free grammar $G$.  A path in $\mathcal{G}$ is an $A$-path for some $A \in N$ if its word is generated by non-terminal $A \in N$ for some grammar $G =\langle\Sigma, N, S, P\rangle$. The all-pairs \textit{CFL-reachability problem} determines the pairs of vertices $(i, j)$, where there exists an $S$-path from $i$ to $j$ in $\mathcal{G}$.



\subsection{Points-to analysis as CFL-reachability problem}
\textit{Points-to analysis} is traditionally presented as the problem of computing a points-to relation that conservatively maps each pointer variable to the heap objects it can point to at runtime. 
Two lvalue expressions are \textit{memory aliases} if they might denote the same memory location. 
Two expressions are \textit{value aliases} if they might evaluate to the same pointer value. 

The most commonly used and actively studied formulation of points-to analysis is Andersen's Pointer Analysis~\cite{Andersen2005ProgramAA}.

Analysis is \textit{field-sensitive}, when it treats each memory object as a collection of disjoint fields.

In this work we use the CFL-reachability formulation of Andersen's Pointer Analysis for C programming language by Zheng and Rugina~\cite{Zheng:2008:DAA:1328897.1328464}~(\ref{subseq:memalias}) and its field-sensitive variant for Java by Sridharan et al. \cite{10.1145/1103845.1094817}~(\ref{subseq:field-sensitive}).

\subsubsection{Memory aliases for C}
\label{subseq:memalias}
\paragraph*{Graph}

The graph representation of all expressions and assignments in the program is called \textit{Program Expression Graph} (PEG). The nodes of the graph represent program expressions, and edges are of four kinds: 
\begin{enumerate}
\item Pointer dereference edges ($d$): for each dereference $*e$, thereis a $d$-edge from $e$ to $*e$
\item Assignment edges ($a$): for each assignment: $*e_1 = e_2$, there is an $a$-edge from $e_2$ to $*e_1$
\item For each $a$-edge, there is a corresponding edge in the opposite direction, denoted by $\bar{a}$
\item For each $d$-edge, there is a corresponding edge in the opposite direction, denoted by $\bar{d}$. 
\end{enumerate}
The example of PEG $\mathcal{G}$ for expressions $\{\texttt{*x, x, \&x, *y, y, \&y}\}$ and assignment \texttt{y = x;} is illustrated in Figure~\ref{fig:example_fsm}.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[shorten >=1pt,auto]
       \node[state] (q_0)                      {\texttt{x}};
       \node[state] (q_2)  [left=of q_0]                    {\texttt{*x}};
       \node[state] (q_3)  [right=of q_0]                    {\texttt{\&x}};
       \node[state] (q_1) [above=of q_0] {\texttt{y}};
       \node[state] (q_4)  [left=of q_1]                    {\texttt{*y}};
       \node[state] (q_5)  [right=of q_1]                    {\texttt{\&y}};
       \path[->]
        (q_0) edge[bend left]   node {$a$} (q_1)
       (q_1) edge[bend left]   node {$\bar{a}$} (q_0)
        (q_0) edge[]   node {$d$} (q_2)
       (q_2) edge[bend left]   node {$\bar{d}$} (q_0)
        (q_0) edge[bend left]   node {$\bar{d}$} (q_3)
       (q_3) edge[]   node {$d$} (q_0)
       (q_1) edge[]   node {$d$} (q_4)
        (q_4) edge[bend left]   node {$\bar{d}$} (q_1)
        (q_1) edge[bend left]   node {$\bar{d}$} (q_5)
       (q_5) edge[]   node {$d$} (q_1)
        ;
    \end{tikzpicture}
    \caption{Program Expression Graph $\mathcal{G}$ for program \texttt{y = x;}}
    \label{fig:example_fsm}
\end{figure}

\paragraph*{Grammar}
The context-free grammar $G_1$ for aliasing problems in EBNF notation, where the star symbol is the Kleene star operator, and the question mark indicates an optional term, is as follows:
\begin{itemize}
\item $S \rightarrow \bar{d}\ V\ d$
\item $V \rightarrow (S? \bar{a})^*\ S?\ (a S?)^*$
\end{itemize}
Terminal symbols $a$ and $d$ represent assignments and dereference edges in the expression graph. Terminal symbols $\bar{a}$ ($\bar{d}$) represents a corresponding edge in the opposite direction for $a$-edge ($d$-edge respectively). Start non-terminal $S$ models memory aliasing relations, and non-terminal $V$ represents value aliasing relations. 


\subsubsection{Field-sensitive points-to analysis for Java}
\label{subseq:field-sensitive}
\paragraph*{Graph}
A program is represented by a \textit{Pointer Assignment Graph} (PAG), a directed graph that records pointer flow in a program. Nodes in the graph are either program variables, or heap-object creation sites. Edges of the graph are defined as follows:
\begin{enumerate}
\item $assign$-edges: for each assignment of program variable $v_1$ to other program variable $v_2$ there is a $assign$-edge from node $v_2$ to node $v_1$
\item $alloc$-edges: for each allocation of heap object $h_1$ and the variable $v_1$ it is assigned to (i.e. \texttt{$v_1$ = new Obj();}) there is an $alloc$-edge from node $h_1$ to node $v_1$
\item $load_f$-edges for all $f \in$ fields: for each reading from a field $f$ of variable $v_1$ (i.e. $v_2 = v_1.f$) there is a $load_f$-edge from node $v_1$ to node $v_2$
\item $store_f$-edges for all $f \in$ fields: for each writing to a field $f$ of variable $v_1$ (i.e. $v_1.f = v_2$) there is a $store_f$-edge from node $v_2$ to node $v_1$
\end{enumerate}
Also, for each edge $n_1 \rightarrow n_2$ labelled $l$ in the graph there is an edge $n_2 \rightarrow n_1$ labelled $\bar{l}$. Given a graph with barred edges, a reverse path $\bar{\pi}$ can be constructed for any path $\pi$ by reversing the order of the edges in $\pi$ and replacing each edge in $\pi$ with its inverse, substituting barred edges for standard edges.

\paragraph*{Grammar}
The productions of the context-free grammar $G_2$ in EBNF notation are described as below:
\begin{itemize}
\item $alias \rightarrow flowsTo\ \overline{flowsTo}$
\item $flowsTo \rightarrow alloc\ (assign\ |\ store_f\ alias\ load_f)^* $ for all $f \in$ fields
\item $\overline{flowsTo} \rightarrow (\overline{assign}\ |\ \overline{load_f}\ alias\ \overline{store_f})^*\ \overline{alloc}$  for all $f \in$ fields.
\end{itemize}
A non-terminal $flowsTo$ represents paths between object-creations and variables, a $\overline{flowsTo}$-path represents the standard points-to relation, and an $alias$-path exists between two variables that might be aliases during the program execution. 

\subsection{Recursive State Machines}
In this work we use the notion of \textit{Finite-State Machine} (FSM).

\begin{definition}
A \textit{deterministic finite-state machine without $\varepsilon$-transitions} $T$ is a tuple $\langle \Sigma, Q, Q_s, Q_f, \delta \rangle$, where:
\begin{itemize}
    \item $\Sigma$ is an input alphabet,
    \item $Q$ is a finite set of states,
    \item $Q_s \subseteq Q$ is a set of start (or initial) states,
    \item $Q_f \subseteq Q$ is a set of final states,
    \item $\delta: Q \times \Sigma \to Q$ is a transition function.
\end{itemize}
\end{definition}

It is well known, that every regular expression can be converted to deterministic FSM without $\varepsilon$-transitions~\cite{automata:theory:10.5555/1177300}. Note, that an edge-labeled graph can be viewed as an FSM where edges represent transitions and all vertices are both start and final at the same time.

While a regular expression can be transformed to an FSM, a context-free grammar can be transformed to a \textit{Recursive State Machine} (RSM) in a similar fashion.
In our work, we use the following definition of RSM based
on~\cite{rsm:analysis:10.1007/3-540-44585-4_18}.

\begin{definition}
A \textit{recursive state machine} $R$ over a finite alphabet $\Sigma$ is defined as a tuple of elements $\langle B,m,\{C_i\}_{i \in B} \rangle$, where:

\begin{itemize}
    \item $B$ is a finite set of labels of boxes,
    \item $m \in B$ is an initial box label,
    \item Set of \textit{component state machines} or \textit{boxes},
          where $C_i=(\Sigma \cup B, Q_i,q_i^0,F_i,\delta_i)$:
    \begin{itemize}
        \item $\Sigma \cup B$ is a set of symbols, $\Sigma \cap B = \varnothing$,
        \item $Q_i$ is a finite set of states,
              where $Q_i \cap Q_j =  \varnothing, \forall i \neq j$,
        \item $q_i^0$ is an initial state for $C_i$,
        \item $F_i$ is a set of final states for $C_i$, where $F_i \subseteq Q_i$,
        \item $\delta_i: Q_i \times (\Sigma \cup B) \to Q_i$ is a transition function. %for $C_i$
    \end{itemize}
\end{itemize}

\end{definition}

RSM behaves as a set of finite state machines (or FSM).
Each such FSM is called a \textit{box} or a \textit{component state machine}.
A box works similarly to the classic FSM, but it also handles additional \textit{recursive calls} and employs an implicit \textit{call stack} to \textit{call} one component from another and then return execution flow back.

\begin{definition}
    The \textit{size of RSM} $|R|$ is defined as the sum of the number of states in all boxes.
\end{definition}

The size of RSM for some grammar $G =\langle\Sigma, N, S, P\rangle$ does not exceed its size $|G|$, which is defined as the sum of the sizes of its productions $|P|$.

RSM for a grammar $G_1$ is illustrated in Figure~\ref{example:rsm}.

\tikzset{every loop/.style={min distance=10mm,looseness=5}}
\begin{figure}[h]
    \begin{tikzpicture}[shorten >=1pt,auto]
        \node[state, initial] (q_0)   {$q_S^0$};
        \node[state] (q_1) [right=of q_0] {$q_S^1$};
        \node[state] (q_2) [right=of q_1] {$q_S^2$};
        \node[state, accepting] (q_3) [right=of q_2] {$q_S^3$};
       \node[state, initial, accepting] (q_4) [below=of q_0]  {$q_V^0$};
      \node[state, accepting] (q_5) [right=of q_4] {$q_V^1$};
 \node[state, accepting] (q_6) [below=of q_4] {$q_V^2$};
 \node[state, accepting] (q_7) [right=of q_6] {$q_V^3$};
        \path[->]
            (q_0) edge node {$\bar{d}$} (q_1)
            (q_1) edge node {$V$} (q_2)
            (q_2) edge node {$d$} (q_3)
             (q_4) edge node {$a$} (q_5)
             (q_6) edge [bend left] node {$ \bar{a}$} (q_4)
            (q_5) edge [bend left] node {$S$} (q_7)
             (q_7) edge [bend left] node {$a$} (q_5)
             (q_6) edge [below] node {$ a$} (q_5)
              (q_4) edge [loop]  node {$\bar{a}$} (q_4)
              (q_5) edge [loop]  node {$a$} (q_5)
             (q_4) edge [bend left]  node {$S$} (q_6);
           % (q_1) edge [bend left, above]  node {b} (q_3);
        \node (box) [draw=black, fit= (q_0) (q_1) (q_2) (q_3), xshift=-4ex, yshift=2ex, inner xsep=0.95cm, inner ysep=0.4cm] {};

        \node[draw=black, anchor=north west] at (box.north west) {Box $S$};

        \node (box2) [draw=black, fit= (q_4) (q_5) (q_6) (q_7), xshift=-4ex, yshift=1.5ex, inner xsep=0.95cm, inner ysep=0.5cm] {};

        \node[draw=black, anchor=north west] at (box2.north west) {Box $V$};
    \end{tikzpicture}
    \centering
    \caption{The recursive state machine $R$ for grammar $G_1$}
    \label{example:rsm}
\end{figure}


\subsection{Linear algebra}
\paragraph*{Matrix representation of machines}
\begin{definition}
An \textit{adjacency matrix} for an edge-labeled directed graph $\mathcal{G} = \langle V,E,L \rangle$ is a matrix $M$, where:
\begin{itemize}
    \item $M$ has size $|V|\times|V|$
    \item $M[i,j] = \{l~\mid e = (i,l,j) \in E\}$
\end{itemize}
\end{definition}

Adjacency matrix $\mathcal{M}_2$ of the labeled graph (FSM) $\mathcal{G}$ is

$$
   \mathcal{M}_2 =
    \begin{pmatrix}
 \emptyset & \{\bar{d}\}  & \emptyset  &\emptyset  & \emptyset  &\emptyset     \\
 \{d\}   & \emptyset   & \{\bar{d}\}  &\emptyset  & \{a\}    &\emptyset     \\
\emptyset & \{d\}  & \emptyset  &\emptyset  & \emptyset  &\emptyset     \\
\emptyset & \emptyset & \emptyset  &\emptyset  & \{\bar{d}\}  &\emptyset     \\
\emptyset & \{\bar{a}\}  & \emptyset  &\{d\}    & \emptyset  &\{\bar{d}\}     \\
\emptyset & \emptyset & \emptyset  &\emptyset  & \{d\}   &\emptyset     \\
    \end{pmatrix}.
$$

Similarly to an FSM, an RSM can be represented as a labeled graph and, hence, as an adjacency matrix.
For our example, $\mathcal{M}_1$ for the RSM $R$ from Figure~\ref{example:rsm} is:
    $$
    \mathcal{M}_1 =
    \begin{pmatrix}
    \emptyset & \{\bar{d}\} &   \emptyset &  \emptyset & \emptyset &  \emptyset &   \emptyset &  \emptyset     \\
    \emptyset &   \emptyset & \{V\}  &  \emptyset & \emptyset & \emptyset  &   \emptyset &  \emptyset     \\
    \emptyset & \emptyset  &   \emptyset & \{d\}  & \emptyset &  \emptyset &   \emptyset &  \emptyset     \\
    \emptyset & \emptyset &   \emptyset &  \emptyset & \emptyset & \emptyset &   \emptyset &  \emptyset     \\
    \emptyset & \emptyset  &   \emptyset &  \emptyset &  \{\bar{a}\}  & \{a\} &   \{S\} &  \emptyset     \\
    \emptyset &  \emptyset  &   \emptyset &  \emptyset & \emptyset & \{a\} &   \emptyset &    \{S\}    \\
    \emptyset &  \emptyset &   \emptyset &  \emptyset &  \{\bar{a}\}  & \{a\} &   \emptyset &  \emptyset     \\
    \emptyset & \emptyset  &  \emptyset & \emptyset & \emptyset   &  \{a\}  &  \emptyset  &   \emptyset    \\
    \end{pmatrix}
    $$

\paragraph*{Graph Kronecker product and machines intersection}
\begin{definition}
Given two matrices $A$ and $B$ of sizes $m_1 \times n_1$ and $m_2 \times n_2$
respectively, with element-wise product operation $\cdot$, the Kronecker product of these two matrices is a new matrix $C = A \otimes B$ of size $m_1 * m_2 \times n_1 * n_2$ and \[C[u * m_2 + v,n_2 * p + q] = A[u,p] \cdot B[v,q].\]
\end{definition}
\begin{definition}
\label{def:graph:product}
Given two edge-labeled directed graphs $\mathcal{G}_1=\langle V_1, E_1, L_1 \rangle$
and $\mathcal{G}_2=\langle V_2, E_2, L_2 \rangle$,
the \textit{Kronecker product} of these two graphs is a edge-labeled directed graph
$\mathcal{G}=\mathcal{G}_1 \otimes \mathcal{G}_2$,
where $\mathcal{G}= \langle V, E, L \rangle$:
\begin{itemize}
    \item $V = V_1 \times V_2$
    \item $E = \{((u,v),l,(p,q)) \mid (u,l,p) \in E_1 \wedge (v,l,q) \in E_2 \}$
    \item $L = L_1 \cap L_2$
\end{itemize}
\end{definition}

The Kronecker product for graphs produces a new graph with a property
that if and only if some path $(u,v)\pi(p,q)$ exists in the result graph
then paths $u\pi_1p$ and $v\pi_2q$ exist in the input graphs,
and $\omega(\pi) = \omega(\pi_1) = \omega(\pi_2)$.
These paths $\pi_1$ and $\pi_2$ can easily be found from $\pi$ by its definition.

The Kronecker product for directed graphs can be described as
the Kronecker product of the corresponding adjacency matrices of graphs,
what gives the following definition:

\begin{definition}
\label{def:graph:adjproduct}
Given two adjacency matrices $M_1$ and $M_2$ of sizes
$m_1 \times n_1$ and $m_2 \times n_2$ respectively
for some directed graphs $\mathcal{G}_1$ and $\mathcal{G}_2$,
the \textit{Kronecker product} of these two adjacency matrices is the adjacency matrix $M$
of some graph $\mathcal{G}$, where $M$ has size $m_1 * m_2 \times n_1 * n_2$ and
\[M[u * m_2 + v,n_2 * p + q] = M_1[u,p] \cap M_2[v,q].\]
\end{definition}

By definition, the Kronecker product for adjacency matrices gives an
adjacency matrix with the same set of edges as in the resulting graph in the
Definition~\ref{def:graph:product}. Thus, $M(\mathcal{G}) = M(\mathcal{G}_1) \otimes
M(\mathcal{G}_2)$, where $\mathcal{G} = \mathcal{G}_1 \otimes \mathcal{G}_2$.

\begin{definition}
\label{def:fsm:intersection}
Given two finite state machines 
$T_1 = \langle \Sigma, Q^1, Q_S^1, Q_F^1, \delta^1 \rangle$ and \\
$T_2 = \langle \Sigma, Q^2, Q_S^2, Q_F^2, \delta^2 \rangle$, the \textit{intersection} of these two machines is a new FSM $T = \langle \Sigma, Q, Q_S, Q_F, \delta \rangle$, where:
\begin{itemize}
    \item $Q = Q^1 \times Q^2$
    \item $Q_S = Q_S^1 \times Q_S^2$
    \item $Q_F = Q_F^1 \times Q_F^2$
    \item $\delta: Q \times \Sigma \to Q$,
    $\delta (\langle q_1, q_2 \rangle, s) = \langle q_1', q_2' \rangle$, if $\delta(q_1,s)=q_1'$ and $\delta(q_2,s)=q_2'$
\end{itemize}
\end{definition}
According to~\cite{automata:theory:10.5555/1177300} an FSM intersection defines the machine for which $L(T) = L(T_1) \cap L(T_2)$.



