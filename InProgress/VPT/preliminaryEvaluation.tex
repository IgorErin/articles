\section{Preliminary Evaluation}

For now, we have implemented some basic functions for the proposed library, which are used in the current evaluation stage: matrix-to-matrix element-wise addition (\verb|mtxAdd|),
matrix-to-scalar \emph{apply-to-all} operation (\verb|map|),
masking (\verb|mask|), which takes a subset of matrix elements, and Kronecker product (\verb|Kron|).
The following examples, which are a combination of the implemented functions, are used for the evaluation. 
The examples are fairly practical, for example, one could see a sequence of element-wise additions in a Luby's maximal independent set algorithm, and masking is a one of key operation in GraphBLAS standard~\cite{buluc2017graphblas}.

\begin{itemize}
\item Sequential addition of four matrices:\\
  \verb|seqAdd m1 m2 m3 m4 = mtxAdd (mtxAdd (mtxAdd m1 m2) m3) m4|
\item Masking of two matrices addition:\\
  \verb|addMask m1 m2 m3 = mask (mtxAdd m1 m2) m3|
\item Masking of two matrices Kronecker product:\\
  \verb|kronMask m1 m2 m3 = mask (kron m1 m2) m3 |  
\item Element-wise processing of two matrices addition:\\
  \verb|addMap m1 m2 = map f (mtxAdd m1 m2)|  
\item Element-wise processing of two matrices Kronecker product:\\
  \verb|kronMap m1 m2 = map f (kron m1 m2)|  
\end{itemize}

We compare original versions of these functions and distilled ones in three ways.
First, we use the interpreter of the POT language to measure the number of reductions and memory reads inside \verb|case| expressions.
We use the simulator shipped with Reduceron to measure the number of clock ticks necessary to evaluate a program, and Vivado's simulator for FHW-compiled programs to measure the number of both clock ticks and memory writes that a program produces.
It is worth noting that Reduceron has somewhat fixed clock frequency, while frequency for FHW-generated hardware varies depending on a particular program. 
Since we do not have external memory at the moment, and all the data lives inside the generated scheme, the logic is not synthesizable for reasonably sized matrices in the case of FHW.
We get similar clock frequencies for distilled and non-distilled programs for inputs with smaller matrices and hence assume that clock frequencies are also similar below. 
Thus, we provide only the number of ticks instead of time.

A set of sparse matrices of appropriate sizes provided at~\cite{Matrices} is used. 
The matrices are converted into boolean ones since POT language lacks the needed primitives at the moment.
Average results for several hundreds of different inputs are presented in table~\ref{tbl:evaluationResults}.

\begin{table}[ht]
    \centering    
    \begin{tabular}{|c|c|c|c|c||c|c|c|c|c|}
        \hline
        \multirow{2}{*}{Function} &  \multicolumn{4}{c||}{Matrix size}  & \multicolumn{2}{c|}{Interpreter}            & Reduceron & \multicolumn{2}{c|}{FHW}\\
        \cline{2-10}
                                  &   m1 & m2 & m3 & m4                & Red-s & Reads                               & Ticks     & Ticks & Writes \\
        \hline
        \hline
        seqAdd   & $64 \times 64$ & $64 \times 64$ & $64 \times 64$ & $64 \times 64$ & 2.7          & 1.9        & 1.8 & 1.4 & 1.1 \\ 
        addMask  & $64 \times 64$ & $64 \times 64$ & $64 \times 64$ & --             & 2.1          & 1.8        & 1.4 & 1.4 & 1.1\\ 
        kronMask & $64 \times 64$ & $2 \times 2$   &$128 \times 128$& --             & 2.2          & 1.9        & 1.4 & 2.7 & 2.5\\ 
        addMap   & $64 \times 64$ & $64 \times 64$ & --             & --             & 2.5          & 1.7        & 1.7 & 1.5 & 1\\
        kronMap  & $64 \times 64$ & $2 \times 2$   & --             & --             & 2.9          & 2.2        & 1.8 & 2.0 & 1\\ 
        \hline
        
    \end{tabular}
    \caption{Evaluation results: original program to distilled one ratio of measured metrics is presented}
    \label{tbl:evaluationResults}
\end{table}

We can see that on average distillation provides up to 3 and 2 times improvement in terms of reductions and memory reads respectively for the interpreter. 
The number of reductions is also considerably reduced for hardware benchmarks. 
The lack of matches between ticks for FHW and Reduceron is justified by architecture distinction. 
Finally, from the last column one could see memory consumption reduction, which supports our approach.
All this hopefully makes the proposed solution viable, and we look forward to coming up with full-fledged experiments that would target real hardware and real life competitors like C++ implementations.
