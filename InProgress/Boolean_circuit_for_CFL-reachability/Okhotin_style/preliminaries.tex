\section{Preliminaries}
\label{sec:prel}
\label{preliminaries}
\paragraph{Formal languages.} 
A \textit{context-free grammar} is a 4-tuple $G = (\Sigma, N, P, S)$, where $\Sigma$ is a finite set of alphabet symbols,  $N$ is a set of nonterminal symbols, $P$ is a set of production rules and $S$ is a start nonterinal. $L(G)$ is a context-free language generated by context-free grammar $G$. We use the notation $A \stackrel {*}{\Rightarrow } w$  to denote that the string $w \in \Sigma^*$ can be derived from a nonterminal $A$ by sequence of applying the production rules from $P$. A \textit{parse tree} is an entity which represents the structure of the derivation of a terminal string from some nonterminal.


A grammar $G$ is said to be is in the \textit{Chomsky normal form}, if all production rules of $P$ are of the form:
$A \rightarrow BC$, $A \rightarrow a$ or $S \rightarrow \varepsilon$, where $A, B, C \in N$ and $a \in \Sigma$. 


The set of all context-free languages is identical to the set of languages accepted by pushdown automata (PDA). \textit{Pushdown automaton} is a 7-tuple $M = (Q, \Sigma, \Gamma, \delta, q_0, Z, F)$, where $Q$ is a finite set of states, $\Sigma$ is a input alphabet, $\Gamma$ is a finite set which is called the stack alphabet, $\delta$ is a finite subset of $Q \times (\Sigma \cap \{\varepsilon\}) \times \Gamma \times Q \times \Gamma^*$,
$q_{0}\in Q$ is the start state, $Z \in \Gamma$ is the initial stack symbol and
$F\subseteq Q$ is the set of accepting states.


Some operations on languages will be mentioned during this paper.


A \textit{homomorphism} is a function $h: \Sigma^* \rightarrow \Delta^*$ defined as follows: 
\begin{itemize}
\item $h(\varepsilon) = \varepsilon$ and for $a \in \Sigma$, $h(a)$ is any string in $\Delta^*$,
\item for $a = a_1a_2 ... a_k \in \Sigma^*$ $(k \ge 2)$, $h(a) = h(a_1)h(a_2)... h(a_k)$.
\end{itemize}
Given a homomorphism $h: \Sigma^* \rightarrow \Delta^*$ and a language $L$ define 
$$h(L)= \{h(w) | w \in L\} \subseteq \Delta^*.$$

Given a homomorphism $h: \Sigma^* \rightarrow \Delta^*$ and a language $L \subseteq \Delta^*$, \textit{inverse homomorphism} defined as follows: 
$$h^{-1}(L)= \{w \in \Sigma^* | h(w) \in L\}.$$ 
$h^{-1}(L)$ consists of strings whose homomorphic images are in $L$.


A \textit{rational transduction} $\tau: \Sigma^* \rightarrow \Delta^*$ can be written as $\tau(w)=\phi(h^{-1}(w) \cap K)$, where $K$ is regular set over finite alphabet $\Gamma$, $\phi$ and $h$ are homomorphism of $\Gamma^* \rightarrow \Delta^*$ and of $\Gamma^* \rightarrow \Sigma^*$ respectively.


The \textit{insertion} of a language $K$ into a language $L$ is a language $$L' = \{uxv|x \in K, u, v \in L\}.$$ 


A \textit{full trio} is a family of languages is closed under arbitrary homomorphism and intersection with regular language. A \textit{full AFL (abstract family of languages)} is a full trio closed under union, concatenation and the Kleene plus. 


A \textit{regular language} is a language that can be expressed with a regular expression or a deterministic or non-deterministic finite automata.
A \textit{nondeterministic finite automaton} (NFA) is represented by a 5-tuple, $(Q,\Sigma ,\delta ,q_{0},F)$, where $Q$ is a finite set of states, $\Sigma$ is a finite set of input symbols, $\delta:Q\times \Sigma \rightarrow 2^{|Q|}$ is a transition function, $q_0 \in Q$ is a start state, $F \subseteq Q$ is a set of accepting (final) states. \textit{Deterministic finite automaton} is a NFA with the following restrictions: each of its transitions is uniquely determined by its source state and input symbol, and reading an input symbol is required for each state transition.


 For a language $L$ over an alphabet $\Sigma$, its rational index $\rho_L$ is a function defined as follows:
$$\rho_L(n) = \max\{\min\{|w|:w \in L \cap K\}, K \in {Rat}_n, L \cap K \neq \emptyset\},$$ where $|w|$ is the length of a word $w$ and ${Rat}_n$ denotes the set of regular languages on an alphabet $\Sigma$, recognized by a finite nondeterministic automation with at most $n$ states.
\paragraph{Context-free language reachability.} 
A \textit{directed labeled graph} is a triple $D = (Q, \Sigma, \delta)$, where $Q$ is a finite set of nodes, $\Sigma$ is a finite set of alphabet symbols,
and $\delta \subseteq Q \times \Sigma \times Q$ is a finite set of labeled edges. Let $L(D)$ denote a graph language~--- a regular language, which is recognized by a NFA obtained from a directed labeled graph $D$.


Let $i\pi j$ denote a unique path between nodes $i$ and $j$ of the input graph and $l(\pi)$ denote a unique string which is obtained from concatenation of edge labels along the path $\pi$. Then the general formulation of the CFL-reachability can be stated as follows.
\begin{definition}[Context-free language reachability]
Let $L \subseteq \Sigma^*$ be a context-free language and $D = (Q, \Sigma, \delta)$ be a directed labeled graph. Given two nodes $i$ and $j$ we say that $j$ is \textit{reachable} from $i$ if there exists a path $i \pi j$, such that $l(\pi) \in L$. 
\end{definition}
There are four varieties of CFL-reachability problems: all-pairs problem, single-source problem, single-target problem and single-source/single-target problem \cite{RepsBasic}. In this paper we consider all-pairs problem. The \textit{all-pairs problem} is to determine all pairs of nodes $i$ and $j$ such that $j$ is reachable from $i$. 

\begin{definition}[Realizable triple]
\label{def:triple}
For a context-free grammar $G = (\Sigma, N, P, S)$ and directed labeled graph $D = (Q, \Sigma, \delta)$, a triple $(A, i, j)$ is \textit{realizable} iff there is a path $i\pi j$ such that $A \stackrel {*}{\Rightarrow } l(\pi)$ for some nontermimal $A \in N$.
\end{definition}
Notice that if there exists a rule $A \rightarrow A_1A_2...A_k \in P$ and a triple $(A, i,  j)$ is realizable then there exist realizable triples $(A_1, i, v_1), (A_2, v_2, v_3), ..., (A_k, v_k, j)$ for some vertices $v_1, ..., v_k$. Also if there exists an edge $(i, j)$ labeled by $a$ and the rule $A \rightarrow a \in P$ then triple $(A, i, j)$ is realizable.

