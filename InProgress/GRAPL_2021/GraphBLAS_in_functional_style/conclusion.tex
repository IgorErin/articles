\section{Conclusion}

We present a work in progress that demonstrates a way to utilize both a power of high-level languages and performance of GPGPUs to implement GraphBLAS API.
Our preliminary evaluation shows that !!!

In the future, first of all, we should extend our library up to full GraphBLAS API implementation.
Moreover, it may be useful for community to implement an analog of LAGraph\footnote{LAGraph is a collection of algorithms implemented using GraphBLAS. Project sources on GitHub: \url{https://github.com/GraphBLAS/LAGraph}. Access date: 12.01.2021.} algorithms collection for .NET on the top of our GraphBLAS API implementation.

The next step is evaluation of the solution on real-world cases and comparison with other implementations of GraphPLAS API on different devices and different algorithms.
Additionally, it may be interesting to compare our solution with graph analysis libraries and with linear algebra libraries for .NET platform.

Another direction of future work is Brahma.FSharp improvements. 
First of all, it is necessary to support discriminated unions to make it possible to express custom semirings such as \texttt{Min-Plus}, as presented in listing~\ref{lst_example}. 

Also, it is necessary to add high-level abstractions for both asynchronous programming and for multi-GPU programming.
Such mechanisms can be naturally expressed in F\# with native primitives for asynchronous programming, and by using high-level abstractions for multiple GPUs management.

Finally, we plan to implement high-level optimizations, like fusion and specialization in Brahma.FSharp.


