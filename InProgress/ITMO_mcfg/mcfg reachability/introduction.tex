\section{Introduction}

Many graph analysis problems can be formulated as formal language-constrained path querying~\cite{doi:10.1137/S0097539798337716} problems where the formal languages are used as constraints for
navigational path queries. More precisely, a path in an edge-labeled graph is viewed as a word (or a string) constructed by the concatenation of edge labels, and the formal languages are used to constrain the paths of interest. When answering a query to the graph some information about paths labeled by words from the given formal language should be found. Recently, the context-free language (CFL) reachability formulation~\cite{reps1998program} become very popular and can be used in many areas, for example, querying graph databeses~\cite{10.1145/3398682.3399163}, RDF analysis~\cite{10.1007/978-3-319-46523-4_38}, static code analysis~\cite{Zheng,10.1145/373243.360208}, biological data analysis~\cite{SubgraphQueriesbyContextfreeGrammars}, graph segmentation~\cite{8731467}.

However, the generative capacity of context-free grammars (CFGs) is too weak to generate natural languages, and the various extensions of CFGs have been proposed to define the syntax of natural languages. \textit{Multiple context-free grammar} (MCFG) is one of such extensions of CFGs. A nonterminal of an MCFG derives tuples of words while the nonterminals of a CFG can only derive words. Using the MCFGs, it is possible to formulate more complex path constraints as, for example, structures involving discontinuous constituents such as "respectively" sentences or inverted sentences in a simple manner.

Therefore, the creation of the MCFL-reachability algorithms allows one to use more complex graph queries. Such algorithms may find application in various areas, for example, in static code analysis. In practice, the Dyck language~\cite{zhang2013fast,kodumal2004set} is the most widely used language in CFL-reachability problem. This language essentially generates the well-matched parentheses. Particularly, many program analyses use the Dyck language to exactly model the \textit{matched-parenthesis} property for \textit{context-sensitivity} or \textit{data-dependence} analysis~\cite{reps2000undecidability}. Namely, context-sensitivity describes the well-balanced procedure calls and returns using open and close parentheses, respectively. Similarly, the data-dependence represents another well-balanced property among language constructors, for example, field accesses (i.e., reads and writes~\cite{bastani2015specification,yan2011demand}), pointer indirections (i.e., references and dereferences~\cite{zheng2008demand}), etc. However, the precise analysis that captures two or more well-balanced properties is undecidable~\cite{reps2000undecidability}. For example, the context-sensitive and data-dependence analysis describes an interleaved matched-parenthesis language which is not even context-free. The traditional approach is to approximate the solution using the CFL-reachabilty algorithms. An interleaved matched-parenthesis language can be viewed as the intersection of two CFLs. However, the CFLs are not closed under intersection~\cite{hopcroft2001introduction}. Therefore, the precision of either context-sensitivity or data-dependence must be sacrificed by approximating the corresponding Dyck language using a regular one~\cite{huang2015scalable,sridharan2006refinement}.

However, for more precise analysis other classes of formal languages can be used. For example, the \textit{linear conjunctive languages} (LCL) can be applied for context-sensitive data-dependence analysis and demonstrate significant precision and scalability advantages of this approach~\cite{zhang2017context}. Thus, the class of \textit{multiple context-free languages} (MCFLs) may also contain the formal languages that can be used to increase the precision of the solution for some program analysis problems. One of the candidates for such a language is the $O_n$ language that can model the matched number of opening and closing parentheses for context-sensitive data-dependence analysis. These languages are approximations of interleaved matched-parenthesis languages and are known not to be context-free. For example, $O_2 = \{w \in \{a, \bar{a}, b, \bar{b}\}^* \mid |w|_a = |w|_{\bar{a}} \wedge |w|_b = |w|_{\bar{b}}\}$.

Despite the fact that, to the best of our knowledge, there is no algorithm for MCFL-reachability, this problem is known to be decidable because the MCFL are closed under intersection with regular languages (i.e. with graphs) and the reachability information can be computed by checking the resulting language for emptiness, which is a decidable problem~\cite{seki1991multiple}.

In practice, the good receipt to achieve high-performance solutions for graph analysis problems is to offload the most critical computations into linear algebra (LA) operations, for example matrix operations~\cite{kepner2016mathematical}. Then such algorithm can be effectively implemented using the high-performance LA libraries with wide class of optimizations like parallel computations~\cite{azimov2021context,azimov2018context}. There are LA-based efficient MCFL recognition algorithms that use the Boolean matrix multiplications~\cite{nakanishi1997efficient,cohen2016parsing} and can form the basis of new MCFL-reachability algorithms. However, the MCFL parsing algorithm in~\cite{cohen2016parsing} can be applied only for some subclass of multiple context-free grammars called \textit{unbalanced}.

To sum up, we make the following contributions in this paper.
\begin{enumerate}
	\item We provide the first MCFL-reachability algorithm by extending the MCFL parsing algorithm from~\cite{nakanishi1997efficient}. Our algorithm is LA-based, hence it allows one to use high-performance libraries and utilize modern parallel hardware.
	\item We implement the proposed algorithm using the pygraphblas\footnote{The pygraphblas GitHub repository: \url{https://github.com/Graphegon/pygraphblas}. Access date: 06.04.2022.} implementation of the GraphBLAS API~\cite{kepner2016mathematical} and evaluate it on some real RDFs and synthetic graphs using some classical MCFLs.
\end{enumerate}