\section{Лекция 12}
 
Парадигмы программирования. Структурное программирование: машины Тьюринга, архитектура фон Неймана, языки-представители.

Начать с автомата (трансдьюсера). Сложение в унарной систее исчисления.

Машина Тьюринга. Машина Поста, нормальные алгорифмы Маркова.

Машина Тьюринга $M=\langle Q,\Gamma ,b,\Sigma ,\delta ,q_{0},F\rangle$:
\begin{itemize}
\item $Q$ --- конечное не пустое множество состояний;
\item $\Gamma$  --- конечное не пустое  множество символов (алфавит);
\item $b \in \Gamma$  специальный пробельный символ;
\item $ \Sigma \subseteq \Gamma \setminus \{b\}$ входной алфавит (то, что можно написать на ленту ``снаружи'' перед стартом);
\item $q_{0}\in Q$ --- стартовое состояние;
\item $F\subseteq Q$ Множество финальных состяний. Говорят, что вход принимается машиной $M$ ечли она оказывается в одном из финальных состояний $F$.
\item $ \delta :(Q\setminus F)\times \Gamma \to Q\times \Gamma \times \{L,R\}$ --- частично определённая функция переходоа. $L$ и $R$ --- команды перемещения головки (влево и вправо соответственно). Если $\delta$  не определена, то машина останавливается.
\end{itemize}

Эмулятор машин Тьюринга: \url{https://turingmachinesimulator.com/}

Архитектура фон Неймана (Принстон). 
\begin{itemize}
	\item Однородность памяти: данные и команды --- одно и то же, хранятся в одной памяти, обрабатываются по общим принципам.
	\item Адресность: память --- это набор занумерованных ячеек.
	\item Программное управление: все действия описываются программой.
\end{itemize}

Узкое место --- канал передачи данных.

Гарвард.
\begin{itemize}
	\item данные и команды разделены. 
\end{itemize}

Проблема: сложнее и дороже. 

Классика: TTA (\url{http://openasip.org/}).




\subsection{Busy beaver}

\begin{itemize}
	\item У машины $n$ состояний + 1 финальное
    \item У машины одна бесконечная в обе стороны лента
    \item Алфавит ленты: $\{0, 1\}$, 0 --- пробельный символ.
    \item Функция перехода получает состояние и текущий символ на ленте, переходит в новое состояние, пишет что-то на ленту, сдвигает головку (налево или направо).
\end{itemize}


Задача: найти терминирующуюся машинутьюринга, записывающую максимальное число 1 на ленту.

Невычислимая функция. 



\subsection{Лямбда-исчисление}

Применение и абстракция. Констант не предполагается.


Сложене в арифметике Пеано.

$\alpha$-эквивалентность --- переименование переменных.

$\beta$-редукция --- вычисление. $(\alpha x.t) a = t[x:=a]$   

$\eta$-преобразование --- заворачивание-разворачивание функций. $\lambda x . f x = f$. Если нет свободных вхождений $x$ в $f$ 

Лямбда-процессоры.

Reduceron: \url{https://www.cs.york.ac.uk/fp/reduceron/}
A Platform for Full-Stack Functional Programming: \url{https://ieeexplore.ieee.org/abstract/document/9180772}
ACQuA: A Parallel Accelerator Architecture for Pure Functional Programs: \url{https://ieeexplore.ieee.org/abstract/document/9155051}

Рекурсивные функции (Гёдель, теория вычислимости).

Кодирование по Чёрчу (Church encoding).

$$
\begin{array}{r|l|l}{\text{Number}}&{\text{Function definition}}&{\text{Lambda expression}}\\\hline 0&0\ f\ x=x&0=\lambda f.\lambda x.x\\1&1\ f\ x=f\ x&1=\lambda f.\lambda x.f\ x\\2&2\ f\ x=f\ (f\ x)&2=\lambda f.\lambda x.f\ (f\ x)\\3&3\ f\ x=f\ (f\ (f\ x))&3=\lambda f.\lambda x.f\ (f\ (f\ x))\\\vdots &\vdots &\vdots \\n&n\ f\ x=f^{n}\ x&n=\lambda f.\lambda x.f^{\circ n}\ x
\end{array}
$$


$$
\operatorname {plus} \equiv \lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x)
$$

$$
\operatorname {succ} \equiv \lambda n.\lambda f.\lambda x.f\ (n\ f\ x)
$$

$$
 \displaystyle \operatorname {mult} \equiv \lambda m.\lambda n.\lambda f.\lambda x.m\ (n\ f)\ x
$$

Функциональное программирование. Понятие лямбда-исчисления, основные принципы и особенности функционального программирования. Языки представители, Haskell, F\#, Ocaml.


%Программирование в зависимых типах. Изоморфизм Карри-Говарда...
    

\subsection{Парадигмы}
Объектно-ориентированное программирование, основные понятия, инкапсуляция, наследование, полиморфизм. Языки-представители. Пример объектно-ориентированного кода на F\#. 

    













    Логическое программирование, Пролог. 
    SWI-prolog:\url{https://swish.swi-prolog.org/}
    \begin{verbatim}
a(1,2).
a(2,3).
a(3,4).
a(4,1).
b(1,5).
b(5,6).
b(6,1).

reachable(X,Y) :- a(X,Z),b(Z,Y).
reachable(X,Y) :- a(X,Z),b(W,Y),reachable(Z,W).
    \end{verbatim}

функционально-логический (лямбда-пролог, ещё кто-то)

    
%    Рекурсивное программирование, Рефал. 

    Стековое программирование, Форт. 
Forth (Форт): \url{https://www.forth.com/resources/forth-programming-language/}


Визуальное программирование, визуальное моделирование, UML, предметно-ориентированное моделирование.

UML examples: \url{https://www.uml-diagrams.org/index-examples.html}

Trik Studio: \url{https://github.com/trikset/trik-studio}
MetaEdit+: \url{https://www.metacase.com/download/metaedit/moremacosx45.html}



